<!-- ====================================================================
	N-Bob Pendulum - Prabhu & GPT 5.2
	Version: 1.4

	What this file is
	- A self-contained HTML/CSS/JS canvas simulation of an N-bob pendulum
	  chain (1-10 bobs).
	- Includes interactive controls (Inputs panel), a live per-bob stats
	  readout (Stats panel), and a trail renderer.
	- Everything lives in this one file: UI, physics integration, rendering,
	  and pointer interaction.

	How to use
	- Drag any bob to set its angle (relative to its parent joint). Release
	  to let it swing.
	- Click empty space to "nudge" the system with a small impulse.
	- You can click slightly near a bob (not only exactly on it).
	- Use Inputs -> Bobs to change the number of bobs.
	- Use Inputs -> Sizes to override the visual radius of each bob (px),
	  e.g. "20, 30, 10".
	  - You can also use "auto" or "-" in a position to revert that bob
	    to automatic sizing.
	- Use Inputs -> Lengths to override each rod length (px),
	  e.g. "auto" or "260, 220, 200".
	  - Use "auto" or "-" per entry to revert that segment to automatic.
	- Press Enter in any Inputs field to apply.
	- Optional: provide Inputs via URL query params (auto-applied on load).
	  Supported params (aliases in parentheses):
	  - bobs (bobCount, n): number of bobs, e.g. ?bobs=4
	  - sizes (bobSizes, radii): per-bob radius list (px), e.g.
	    &sizes=20,30,10,14
	  - lengths (bobLengths, lens): per-bob rod length list (px), e.g.
	    &lengths=auto,250,-,200
	  Notes:
	  - Lists can be comma- or space-separated.
	  - Use "auto" or "-" per entry to revert that value.
	  - You can combine these with ?tests=1.
	  Examples:
	  - pendulum.html?bobs=5
	  - pendulum.html?bobs=4&sizes=20,30,10,14
	  - pendulum.html?bobs=4&lengths=auto,250,-,200
	  - pendulum.html?bobs=6&sizes=auto,26,24,22,20,18&tests=1
	- Optional: add ?tests=1 to the URL to show a Tests panel and run the
	  embedded unit tests (no external runner required).
	  - Tests show numbered PASS/FAIL output and simple function coverage.

	High-level architecture
	- State: angles (theta[]) and angular velocities (omega[]) per bob.
	- Params: rod lengths, masses, damping, dt limits, trail length, and
	  optional per-bob radius overrides.
	- Physics:
	  - Computes angular accelerations by building a dense linear system
	    A*alpha=b and solving it each step.
	  - Integrates the ODE using RK4 (Runge-Kutta 4) with sub-stepping.
	- Rendering:
	  - Canvas is full-viewport; each frame draws vignette, trails, rods,
	    ground shadows, and bobs.
	  - Trails are stored as per-bob point buffers.
	- UI:
	  - Three minimizable panels (Inputs, Stats, Tests).
	  - Panels use +/− toggles and overlay the pendulum area (opening a
	    panel does not resize the canvas).
	  - Stats shows a table for every bob: measured period/frequency (from
	    recent oscillations), angle, angular velocity, and speed.

	Notes / tradeoffs
	- This is a visualization-oriented simulation ("looks/feels" realistic)
	  rather than a rigorously exact physical model; constants like gEff are
	  tuned for pleasing motion at screen scale.
	- To keep the UI responsive, matrix sizes are limited (N<=10) and the
	  solver is a straightforward Gaussian elimination with pivoting.
-->
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Pendulum</title>
		<style>
			/* Layout: full-viewport canvas */
			/* plus a small HUD stack (Inputs + Stats). */
			:root {
				color-scheme: dark;
			}

			html,
			body {
				height: 100%;
				margin: 0;
			}

			body {
				font-family:
					system-ui,
					-apple-system,
					Segoe UI,
					Roboto,
					Arial,
					sans-serif;
				background: radial-gradient(
					1200px 800px at 50% 20%,
					#1a2230 0%,
					#0b0f14 55%,
					#05070a 100%
				);
				overflow: hidden;
			}

			/* Canvas fills the viewport; JS sets backing resolution via DPR. */
			.wrap {
				position: fixed;
				inset: 0;
				padding: 10px 10px 28px;
			}

			canvas {
				width: 100%;
				height: 100%;
				display: block;
				border-radius: 18px;
				background: transparent;
				touch-action: none;
				-webkit-tap-highlight-color: transparent;
				box-shadow:
					0 0 0 1px rgba(255, 255, 255, 0.06),
					0 18px 60px rgba(0, 0, 0, 0.55);
			}

			/* Hint pill at bottom; pointer-events disabled */
			/* so it never blocks drag. */
			.hint {
				position: fixed;
				left: 50%;
				top: 10px;
				transform: translateX(-50%);
				font-size: 11px;
				color: rgba(255, 255, 255, 0.65);
				user-select: none;
				pointer-events: none;
				text-align: center;
				padding: 6px 10px;
				border-radius: 999px;
				background: rgba(0, 0, 0, 0.25);
				backdrop-filter: blur(10px);
			}

			/* Bottom-left footer label. */
			#copyright {
				position: fixed;
				left: 12px;
				bottom: 6px;
				font-size: 11px;
				color: rgba(255, 255, 255, 0.45);
				user-select: none;
				pointer-events: none;
			}

			/* HUD stacks: panels; canvas interaction still works. */
			.hud-left,
			.hud-right {
				position: fixed;
				bottom: 28px;
				display: flex;
				flex-direction: column;
				gap: 10px;
				max-width: min(420px, calc(50vw - 18px));
				pointer-events: none;
			}

			.hud-left {
				left: 12px;
			}

			.hud-right {
				right: 12px;
			}

			/* Phone portrait: keep stacks on bottom corners. */
			@media (max-width: 640px) and (orientation: portrait) {
				.hud-left,
				.hud-right {
					bottom: 28px;
					max-width: min(360px, calc(100vw - 24px));
				}

				.hud-left {
					left: 12px;
				}

				.hud-right {
					right: 12px;
				}

				.wrap {
					padding: 6px 6px 26px;
				}
			}

			/* Shared panel styling for Inputs and Stats. */
			.panel {
				pointer-events: auto;
				padding: 10px 12px;
				border-radius: 12px;
				background: rgba(0, 0, 0, 0.28);
				backdrop-filter: blur(10px);
				box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06);
				color: rgba(255, 255, 255, 0.78);
				font-size: 12px;
				line-height: 1.35;
				user-select: text;
			}

			.panel .header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 10px;
				margin-bottom: 6px;
			}

			.panel .title {
				font-size: 12px;
				letter-spacing: 0.06em;
				text-transform: uppercase;
				color: rgba(255, 255, 255, 0.62);
				margin: 0;
			}

			.panel .minbtn {
				user-select: none;
				width: 28px;
				height: 28px;
				padding: 0;
				border-radius: 999px;
				border: 1px solid rgba(255, 255, 255, 0.10);
				background: rgba(255, 255, 255, 0.07);
				color: rgba(255, 255, 255, 0.85);
				cursor: pointer;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				font-weight: 700;
				font-size: 16px;
				line-height: 1;
			}

			.panel .minbtn:hover {
				background: rgba(255, 255, 255, 0.10);
			}

			.panel .controls {
				display: flex;
				align-items: center;
				gap: 8px;
				margin: 0 0 8px;
				flex-wrap: wrap;
			}

			/* Inputs panel: stack labels/fields neatly. */
			.inputs-controls {
				display: grid;
				grid-template-columns: auto auto minmax(0, 1fr);
				gap: 6px 8px;
				align-items: center;
				margin: 0 0 8px;
			}

			.inputs-controls input[type='number'],
			.inputs-controls input[type='text'] {
				width: 100%;
				min-width: 0;
			}

			.inputs-controls button {
				justify-self: start;
			}

			/* Default layout for label/value rows. */
			.inputs-controls label {
				grid-column: 1;
			}

			.inputs-controls input {
				grid-column: 2 / -1;
			}

			/* Apply + Share URL on the same row. */
			.inputs-controls #applyBobs {
				grid-column: 1;
			}

			.inputs-controls label[for='shareUrl'] {
				grid-column: 2;
				white-space: nowrap;
			}

			.inputs-controls #shareUrl {
				grid-column: 3;
				width: 100%;
				min-width: 0;
				box-sizing: border-box;
			}

			.panel label {
				color: rgba(255, 255, 255, 0.70);
			}

			.panel input[type='number'],
			.panel input[type='text'] {
				width: 72px;
				padding: 6px 8px;
				border-radius: 10px;
				border: 1px solid rgba(255, 255, 255, 0.10);
				background: rgba(255, 255, 255, 0.06);
				color: rgba(255, 255, 255, 0.88);
				outline: none;
			}

			.panel input::placeholder {
				color: rgba(255, 255, 255, 0.42);
			}

			.panel input[type='text'] {
				width: 190px;
			}

			.panel button {
				padding: 6px 10px;
				border-radius: 10px;
				border: 1px solid rgba(255, 255, 255, 0.10);
				background: rgba(255, 255, 255, 0.07);
				color: rgba(255, 255, 255, 0.85);
				cursor: pointer;
			}

			.panel button:hover {
				background: rgba(255, 255, 255, 0.10);
			}

			.panel pre {
				margin: 0;
				white-space: pre;
				font-family:
					ui-monospace,
					SFMono-Regular,
					Menlo,
					Monaco,
					Consolas,
					"Liberation Mono",
					"Courier New",
					monospace;
				color: rgba(255, 255, 255, 0.82);
			}

			/* Test output helpers (only visible in ?tests=1 mode). */
			.test-pass {
				color: #3fb950;
			}

			.test-fail {
				color: #f85149;
			}

			.test-dim {
				color: rgba(255, 255, 255, 0.55);
			}

			/* Stats coloring helpers (monospace output in the Stats panel). */
			.stat-pos {
				color: #3fb950;
			}

			.stat-neg {
				color: #f85149;
			}

			.stat-hdr {
				color: rgba(255, 255, 255, 0.62);
			}

			.stat-sel {
				color: rgba(255, 255, 255, 0.92);
			}

			/* Keep Tests output from growing unbounded. */
			#testsText {
				max-height: 45vh;
				overflow: auto;
			}

			/* Collapsed panels only show the header and toggle button. */
			.panel.is-collapsed {
				max-width: min(220px, calc(100vw - 24px));
				padding-bottom: 8px;
			}

			.panel.is-collapsed .content {
				display: none;
			}

			@media (prefers-reduced-motion: reduce) {
				.hint::after {
					content: " (reduced motion)";
				}
			}
		</style>
	</head>
	<body>
		<div class="wrap">
			<canvas id="c"></canvas>
		</div>
		<!--
			HUD = small overlay UI.
			Both panels start collapsed; user can expand independently.
			Inputs contains configurable parameters.
			Stats contains the live readout.
		-->
		<div class="hud-left">
			<div id="inputsPanel" class="panel is-collapsed">
				<div class="header">
					<div class="title">Inputs</div>
					<button
						id="toggleInputs"
						class="minbtn"
						type="button"
						aria-expanded="false"
					>
						+
					</button>
				</div>
				<div class="content">
					<div class="inputs-controls">
						<label for="bobCount">Bobs</label>
						<input
							id="bobCount"
							type="text"
							inputmode="numeric"
							pattern="[0-9]*"
							value="3"
							placeholder="1-10"
						/>
						<label for="bobSizes">Sizes</label>
						<input
							id="bobSizes"
							type="text"
							inputmode="decimal"
							value="20, 30, 10"
							placeholder="e.g. 20,22,24 (px radius)"
						/>
						<label for="bobLengths">Lengths</label>
						<input
							id="bobLengths"
							type="text"
							inputmode="decimal"
							value="auto"
							placeholder="e.g. auto or 260,220,200 (px)"
						/>
						<button id="applyBobs" type="button">Apply</button>
						<label for="shareUrl">Share URL</label>
						<input
							id="shareUrl"
							type="text"
							readonly
							spellcheck="false"
							placeholder="Applied URL appears here"
						/>
					</div>
					<div class="test-dim">
						Bobs: 1 to 10.
						Sizes/Lengths: comma-separated (one per bob).
						Use "auto" or "-" to reset a value.
						Click Apply to use changes.
					</div>
				</div>
			</div>
		</div>
		<div class="hud-right">
			<div id="statsPanel" class="panel is-collapsed" aria-live="polite">
				<div class="header">
					<div class="title">Stats</div>
					<button
						id="toggleStats"
						class="minbtn"
						type="button"
						aria-expanded="false"
					>
						+
					</button>
				</div>
				<div class="content">
					<pre id="statsText">Initializing...</pre>
				</div>
			</div>
			<div
				id="testsPanel"
				class="panel is-collapsed"
				hidden
				aria-live="polite"
			>
				<div class="header">
					<div class="title">Tests</div>
					<button
						id="toggleTests"
						class="minbtn"
						type="button"
						aria-expanded="false"
					>
						+
					</button>
				</div>
				<div class="content">
					<div class="controls">
						<button id="runTests" type="button">Run</button>
					</div>
					<pre id="testsText">Ready.</pre>
				</div>
			</div>
		</div>
		<div class="hint">
			Drag a bob. Click to nudge.
		</div>
		<div id="copyright">(c) N-Bob Pendulum - Prabhu &amp; GPT 5.2</div>

		<script>
			(() => {
				// =============================================================
				// DOM / UI wiring
				//
				// This demo is intended to be resilient even if a DOM element
				// is missing (e.g., partial copy/paste, or an unsupported
				// browser environment). We prefer to fail "softly": write an
				// error to the Stats panel (if present) and stop.
				// =============================================================
				const statsText = document.getElementById('statsText');
				const canvas = document.getElementById('c');
				if (!canvas) {
					if (statsText) {
						statsText.textContent =
							'Error: canvas element (#c) not found.';
					}
					return;
				}
				const ctx = canvas.getContext('2d');
				if (!ctx) {
					if (statsText) {
						statsText.textContent =
							'Error: Canvas 2D context not available.';
					}
					return;
				}

				const inputsPanel = document.getElementById('inputsPanel');
				const toggleInputsBtn = document.getElementById('toggleInputs');
				const statsPanel = document.getElementById('statsPanel');
				const toggleStatsBtn = document.getElementById('toggleStats');
				const testsPanel = document.getElementById('testsPanel');
				const toggleTestsBtn = document.getElementById('toggleTests');
				const runTestsBtn = document.getElementById('runTests');
				const testsText = document.getElementById('testsText');
				const bobCountInput = document.getElementById('bobCount');
				const bobSizesInput = document.getElementById('bobSizes');
				const bobLengthsInput = document.getElementById('bobLengths');
				const applyBobsBtn = document.getElementById('applyBobs');
				const shareUrlInput = document.getElementById('shareUrl');

				// ---------------------------------------------------------
				// URL -> Inputs parameters
				//
				// Allow setting the Inputs panel via query params.
				// Examples:
				//   ?bobs=4&sizes=20,30,10,14&lengths=auto,250,-,200
				// Aliases are supported for convenience.
				//
				// Note: We only populate the input fields here.
				// applyBobCountFromUI() runs at startup and will apply them.
				// ---------------------------------------------------------
				function applyInputsFromQuery(searchOrParams) {
					let qs;
					try {
						qs =
							searchOrParams instanceof URLSearchParams
								? searchOrParams
								: new URLSearchParams(
										String(searchOrParams ?? window.location.search)
								);
					} catch {
						return false;
					}
					const getFirst = (keys) => {
						for (const k of keys) {
							const v = qs.get(k);
							if (v !== null) return v;
						}
						return null;
					};

					let changed = false;
					const bobs = getFirst(['bobs', 'bobCount', 'n']);
					const sizes = getFirst(['sizes', 'bobSizes', 'radii']);
					const lengths = getFirst(['lengths', 'bobLengths', 'lens']);

					if (bobs !== null && bobCountInput) {
						bobCountInput.value = bobs;
						changed = true;
					}
					if (sizes !== null && bobSizesInput) {
						bobSizesInput.value = sizes;
						changed = true;
					}
					if (lengths !== null && bobLengthsInput) {
						bobLengthsInput.value = lengths;
						changed = true;
					}
					return changed;
				}

				function normalizeListText(raw, fallback) {
					const s = String(raw ?? '').trim();
					if (s.length === 0) return fallback;
					const parts = s
						.split(/[\s,]+/)
						.map((x) => x.trim())
						.filter(Boolean)
						.map((x) => {
							const t = x.toLowerCase();
							if (t === 'auto') return 'auto';
							if (t === '-') return '-';
							return x;
						});
					if (parts.length === 0) return fallback;
					return parts.join(',');
				}

				function updateShareUrlFromInputs() {
					if (!shareUrlInput) return;
					try {
						const u = new URL(window.location.href);
						const qs = u.searchParams;
						const bobs =
							String(state.count) ||
							String(bobCountInput?.value ?? '').trim();
						const sizes = normalizeListText(
							bobSizesInput?.value,
							'auto'
						);
						const lengths = normalizeListText(
							bobLengthsInput?.value,
							'auto'
						);

						qs.set('bobs', bobs);
						qs.set('sizes', sizes);
						qs.set('lengths', lengths);
						shareUrlInput.value = u.toString();
					} catch {
						// no-op
					}
				}

				if (shareUrlInput) {
					const selectAll = () => {
						try {
							shareUrlInput.focus();
							shareUrlInput.select();
						} catch {
							// no-op
						}
					};
					shareUrlInput.addEventListener('click', selectAll);
					shareUrlInput.addEventListener('focus', selectAll);
				}

				// Panels intentionally overlay the canvas.
				// The pendulum area should remain a stable size whether panels
				// are expanded or collapsed.

				// ---------------------------------------------------------
				// Test mode flag
				//
				// Unit tests are intentionally hidden in normal use.
				// Add ?tests=1 to the URL to enable the Tests panel.
				// ---------------------------------------------------------
				const testsEnabled = (() => {
					try {
						const qs = new URLSearchParams(window.location.search);
						return qs.get('tests') === '1';
					} catch {
						return false;
					}
				})();

				// ---------------------------------------------------------
				// Optional coverage counters (tests mode only)
				//
				// This is intentionally simple: function-level hit counts.
				// We reset coverage at the start of a test run.
				// ---------------------------------------------------------
				let testsRunning = false;
				const covKeys = [
					'resizeCanvas',
					'setBobCount',
					'layout',
					'solveLinearSystem',
					'accelerations',
					'deriv',
					'rk4Step',
					'forwardKinematics',
					'clearTrails',
					'pushTrail',
					'drawTrail',
					'draw',
					'pointerToThetaFromPoint',
					'hitTest',
					'nudge',
					'updateStats',
					'tick',
					'applyBobCountFromUI',
				];
				const cov = testsEnabled
					? { keys: covKeys, hits: Object.create(null) }
					: null;

				function covHit(key) {
					if (!cov) return;
					cov.hits[key] = (cov.hits[key] || 0) + 1;
				}

				function covReset() {
					if (!cov) return;
					for (const k of cov.keys) delete cov.hits[k];
				}

				// -------------------------------------------------------------
				// Collapsible panel helper
				//
				// - Controls a CSS class (.is-collapsed) which hides .content.
				// - Updates button text for clarity.
				// - Keeps aria-expanded in sync for assistive tech.
				// -------------------------------------------------------------
				function wireCollapsiblePanel(panelEl, buttonEl, label) {
					if (!panelEl || !buttonEl) return () => {};
					const showLabel = `Show ${label}`;
					const hideLabel = `Minimize ${label}`;
					const setCollapsed = (collapsed) => {
						panelEl.classList.toggle('is-collapsed', collapsed);
						buttonEl.textContent = collapsed ? '+' : '−';
						buttonEl.setAttribute(
							'aria-expanded',
							collapsed ? 'false' : 'true'
						);
						buttonEl.setAttribute(
							'aria-label',
							collapsed ? showLabel : hideLabel
						);
						buttonEl.title = collapsed ? showLabel : hideLabel;
					};
					buttonEl.addEventListener('click', () => {
						const collapsedClass = 'is-collapsed';
						const isCollapsed = panelEl.classList.contains(
							collapsedClass
						);
						setCollapsed(!isCollapsed);
					});
					setCollapsed(true);
					return setCollapsed;
				}

				const setInputsCollapsed = wireCollapsiblePanel(
					inputsPanel,
					toggleInputsBtn,
					'Inputs'
				);
				const setStatsCollapsed = wireCollapsiblePanel(
					statsPanel,
					toggleStatsBtn,
					'Stats'
				);
				let setTestsCollapsed = () => {};
				if (testsPanel) {
					testsPanel.hidden = !testsEnabled;
					if (testsEnabled) {
						setTestsCollapsed = wireCollapsiblePanel(
							testsPanel,
							toggleTestsBtn,
							'Tests'
						);
					}
				}

				// Snapshot panel startup state for unit tests.
				const panelStartup = testsEnabled
					? {
						inputsCollapsed:
							inputsPanel?.classList.contains('is-collapsed') ??
							false,
						statsCollapsed:
							statsPanel?.classList.contains('is-collapsed') ??
							false,
						testsCollapsed:
							testsPanel?.classList.contains('is-collapsed') ??
							false,
					}
					: null;

				// -------------------------------------------------------------
				// Accessibility / performance switches
				//
				// If the user prefers reduced motion, keep the app responsive
				// but skip physics integration and trail accumulation.
				// -------------------------------------------------------------
				const reducedMotionQuery = '(prefers-reduced-motion: reduce)';
				const prefersReducedMotion =
					window.matchMedia?.(reducedMotionQuery)?.matches ?? false;
				const TAU = Math.PI * 2;

				// ===== Small math helpers =====
				function clamp(v, a, b) {
					return Math.max(a, Math.min(b, v));
				}

				function radToDeg(r) {
					return (r * 180) / Math.PI;
				}

				function fmt(n, digits = 2) {
					if (!Number.isFinite(n)) return '—';
					return n.toFixed(digits);
				}

				// -------------------------------------------------------------
				// Canvas sizing
				//
				// The canvas is styled in CSS; to avoid blur, set its
				// backing buffer size in device pixels (DPR-aware), then scale
				// drawing coordinates back to CSS pixels.
				// -------------------------------------------------------------
				function resizeCanvas() {
					covHit('resizeCanvas');
					const dpr = Math.max(
						1,
						Math.min(8, window.devicePixelRatio || 1)
					);
					const rect = canvas.getBoundingClientRect();
					canvas.width = Math.floor(rect.width * dpr);
					canvas.height = Math.floor(rect.height * dpr);
					ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
				}

				// =============================================================
				// Simulation state
				// =============================================================
				// Angles are measured from vertical;
				// positive rotates to the right.
				const state = {
					count: 3,
					theta: [0.95, 1.20, 1.45],
					omega: [0.0, 0.0, 0.0],
					dragging: false,
					dragIndex: 2,
					lastT: performance.now(),
					simTime: 0,
				};

				// =============================================================
				// Period/frequency tracking (measured)
				// =============================================================
				// We estimate each bob's oscillation period by detecting peaks:
				// a local max/min occurs when omega changes sign. Time between
				// successive peaks of the same sign gives one full period.
				// The estimate is smoothed to avoid jitter.
				const periodTrack = {
					lastOmega: [],
					lastPosPeakT: [],
					lastNegPeakT: [],
					estT: [],
					lastSampleT: NaN,
				};

				function resetPeriodTracker() {
					const n = state.count;
					periodTrack.lastOmega = new Array(n);
					periodTrack.lastPosPeakT = new Array(n);
					periodTrack.lastNegPeakT = new Array(n);
					periodTrack.estT = new Array(n);
					periodTrack.lastSampleT = NaN;
					for (let i = 0; i < n; i++) {
						periodTrack.lastOmega[i] = state.omega[i] ?? 0;
						periodTrack.lastPosPeakT[i] = NaN;
						periodTrack.lastNegPeakT[i] = NaN;
						periodTrack.estT[i] = NaN;
					}
				}

				function updatePeriodTracker(t) {
					const n = state.count;
					if (periodTrack.lastOmega.length !== n) resetPeriodTracker();
					const tPrev = periodTrack.lastSampleT;
					periodTrack.lastSampleT = t;
					const thetaMin = 0.08;
					const alpha = 0.25;
					const canInterp =
						Number.isFinite(tPrev) && Number.isFinite(t) && t > tPrev;

					for (let i = 0; i < n; i++) {
						const prevW = periodTrack.lastOmega[i];
						const w = state.omega[i];
						periodTrack.lastOmega[i] = w;
						if (!Number.isFinite(prevW) || !Number.isFinite(w)) continue;
						if (!Number.isFinite(t)) continue;

						const th = state.theta[i];
						if (!Number.isFinite(th) || Math.abs(th) < thetaMin) continue;

						// Local maximum: omega crosses from + to -.
						if (prevW > 0 && w <= 0) {
							let tPeak = t;
							if (canInterp && w !== prevW) {
								const u = (0 - prevW) / (w - prevW);
								tPeak = tPrev + (t - tPrev) * clamp(u, 0, 1);
							}
							const last = periodTrack.lastPosPeakT[i];
							if (Number.isFinite(last)) {
								const T = tPeak - last;
								if (Number.isFinite(T) && T > 0.05 && T < 60) {
									const cur = periodTrack.estT[i];
									periodTrack.estT[i] = Number.isFinite(cur)
										? cur * (1 - alpha) + T * alpha
										: T;
								}
							}
							periodTrack.lastPosPeakT[i] = tPeak;
							continue;
						}

						// Local minimum: omega crosses from - to +.
						if (prevW < 0 && w >= 0) {
							let tPeak = t;
							if (canInterp && w !== prevW) {
								const u = (0 - prevW) / (w - prevW);
								tPeak = tPrev + (t - tPrev) * clamp(u, 0, 1);
							}
							const last = periodTrack.lastNegPeakT[i];
							if (Number.isFinite(last)) {
								const T = tPeak - last;
								if (Number.isFinite(T) && T > 0.05 && T < 60) {
									const cur = periodTrack.estT[i];
									periodTrack.estT[i] = Number.isFinite(cur)
										? cur * (1 - alpha) + T * alpha
										: T;
								}
							}
							periodTrack.lastNegPeakT[i] = tPeak;
						}
					}
				}

				// =============================================================
				// Tunable parameters
				// =============================================================
				// Note: `g` is used only to compute a screen-scaled gEff.
				const params = {
					g: 9.81,
					lengths: [260, 220, 200],
					// Optional per-segment length overrides (px).
					// Use null for auto.
					lengthOverrides: [null, null, null],
					masses: [1.0, 1.0, 1.0],
					damping: [0.01, 0.012, 0.012],
					// Optional per-bob radius overrides (px).
					// Use null for auto.
					radiusOverrides: [20, 30, 10],
					maxStep: 1 / 90,
					trailLen: 220,
				};

				// Snapshot file defaults for tests.
				// This makes tests robust even if the user edits Inputs
				// before clicking Run.
				const defaults = testsEnabled
					? {
						bobCountAttr:
							bobCountInput?.getAttribute('value') ?? '',
						bobSizesAttr:
							bobSizesInput?.getAttribute('value') ?? '',
						bobLengthsAttr:
							bobLengthsInput?.getAttribute('value') ?? '',
						lengthOverrides: params.lengthOverrides.slice(),
						radiusOverrides: params.radiusOverrides.slice(),
					}
					: null;

				let trails = Array.from({ length: state.count }, () => []);

				// -------------------------------------------------------------
				// State resizing
				//
				// When changing bob count N:
				// - Keep previous angles/velocities where possible.
				// - Resize parameter arrays (lengths, masses, damping, radii).
				// - Reset trails (old ones mismatch new geometry).
				// -------------------------------------------------------------
				function setBobCount(nextCount) {
					covHit('setBobCount');
					let n = Math.trunc(nextCount);
					if (!Number.isFinite(n)) n = state.count;
					n = clamp(n, 1, 10);
					const prevTheta = state.theta;
					const prevOmega = state.omega;
					const prevR = params.radiusOverrides;
					const prevL = params.lengthOverrides;
					state.count = n;

					state.theta = new Array(n);
					state.omega = new Array(n);
					for (let i = 0; i < n; i++) {
						state.theta[i] = prevTheta[i] ?? (0.75 + 0.18 * i);
						state.omega[i] = prevOmega[i] ?? 0.0;
					}

					params.lengths = new Array(n).fill(200);
					params.lengthOverrides = new Array(n);
					for (let i = 0; i < n; i++) {
						params.lengthOverrides[i] = prevL[i] ?? null;
					}
					params.masses = new Array(n).fill(1.0);
					params.damping = new Array(n).fill(0.012);
					params.damping[0] = 0.01;
					params.radiusOverrides = new Array(n);
					for (let i = 0; i < n; i++) {
						params.radiusOverrides[i] = prevR[i] ?? null;
					}

					state.dragIndex = clamp(state.dragIndex, 0, n - 1);
					trails = Array.from({ length: n }, () => []);
					resetPeriodTracker();
				}

				// =============================================================
				// Layout (screen-space)
				// =============================================================
				// Computes pivot + bob radii;
				// also updates rod lengths from viewport.
				//
				// IMPORTANT: layout() has a deliberate side-effect:
				// it updates params.lengths[] each call based on the current
				// viewport. This keeps the visual system scaled to the window.
				function layout() {
					covHit('layout');
					const rect = canvas.getBoundingClientRect();
					const w = rect.width;
					const h = rect.height;
					const aspect = w > 0 ? h / w : 1;
					const isPortrait = aspect >= 1.20;

					const pivot = {
						x: w * 0.5,
						y: h * (isPortrait ? 0.16 : 0.22),
					};

					const n = state.count;
					const totalLen = Math.min(
						h * (isPortrait ? 0.74 : 0.62),
						w * (isPortrait ? 0.80 : 0.50)
					);
					const base = clamp(
						(totalLen / Math.max(1, n)) * 0.92,
						80,
						260
					);
					for (let i = 0; i < n; i++) {
						const autoLen = base * (1 - 0.03 * i);
						const ov = params.lengthOverrides[i];
						if (Number.isFinite(ov) && ov > 0) {
							params.lengths[i] = clamp(ov, 40, 420);
						} else {
							params.lengths[i] = autoLen;
						}
					}

					const bobRadiusAuto = (i) =>
						clamp(
							params.lengths[i] *
								(0.10 + 0.015 * Math.min(4, i)),
							14,
							42
						);
					const bobRadius = (i) => {
						const r = params.radiusOverrides[i];
						if (Number.isFinite(r) && r > 0) return clamp(r, 6, 80);
						return bobRadiusAuto(i);
					};
					return { w, h, pivot, bobRadius };
				}

				// =============================================================
				// Linear algebra (small dense solver)
				// =============================================================
				// Solves A*x=b via Gaussian elimination with partial pivoting.
				//
				// Notes:
				// - Operates on copies of A and b to avoid mutating inputs.
				// - Returns a zero vector if the matrix is near-singular.
				function solveLinearSystem(A, b) {
					covHit('solveLinearSystem');
					const n = b.length;
					const M = A.map((row) => row.slice());
					const x = b.slice();

					for (let col = 0; col < n; col++) {
						let pivot = col;
						let maxAbs = Math.abs(M[col][col]);
						for (let r = col + 1; r < n; r++) {
							const v = Math.abs(M[r][col]);
							if (v > maxAbs) {
								maxAbs = v;
								pivot = r;
							}
						}
						if (maxAbs < 1e-12) return new Array(n).fill(0);

						if (pivot !== col) {
							const tmpRow = M[col];
							M[col] = M[pivot];
							M[pivot] = tmpRow;
							const tmpB = x[col];
							x[col] = x[pivot];
							x[pivot] = tmpB;
						}

						const diag = M[col][col];
						for (let c = col; c < n; c++) M[col][c] /= diag;
						x[col] /= diag;

						for (let r = col + 1; r < n; r++) {
							const factor = M[r][col];
							if (factor === 0) continue;
							for (let c = col; c < n; c++) {
								M[r][c] -= factor * M[col][c];
							}
							x[r] -= factor * x[col];
						}
					}

					for (let r = n - 1; r >= 0; r--) {
						for (let c = r + 1; c < n; c++) x[r] -= M[r][c] * x[c];
					}
					return x;
				}

				// =============================================================
				// Physics model (approximate chain dynamics)
				// =============================================================
				// Computes angular accelerations for the chain
				// given (theta, omega).
				// Builds dense system A*alpha=b where alpha
				// is angular acceleration.
				// Additional notes:
				// - Mtail[i] is total mass below joint i (inclusive);
				//   used to approximate coupling.
				// - gEff is an *effective* gravity scaled for screen-space.
				// - Damping is per-joint and acts like angular drag.
				function accelerations(theta, omega) {
					covHit('accelerations');
					const n = theta.length;
					const l = params.lengths;
					const m = params.masses;
					const d = params.damping;

					const Mtail = new Array(n);
					let accMass = 0;
					for (let i = n - 1; i >= 0; i--) {
						accMass += m[i];
						Mtail[i] = accMass;
					}

					const A = Array.from({ length: n }, () => {
						return new Array(n).fill(0);
					});
					const b = new Array(n).fill(0);
					const gEff = params.g * 110;

					for (let i = 0; i < n; i++) {
						b[i] =
							-gEff *
							Mtail[i] *
							l[i] *
							Math.sin(theta[i]) -
							d[i] *
							omega[i];
						for (let j = 0; j < n; j++) {
							const k = Math.max(i, j);
							const Mmax = Mtail[k];
							A[i][j] =
								Mmax *
								l[i] *
								l[j] *
								Math.cos(theta[i] - theta[j]);
							b[i] +=
								-Mmax *
								l[i] *
								l[j] *
								Math.sin(theta[i] - theta[j]) *
								(omega[j] * omega[j]);
						}
					}

					return solveLinearSystem(A, b);
				}

				// Packs/unpacks the state vector for the integrator:
				// y=[theta..., omega...]
				function deriv(y) {
					covHit('deriv');
					const n = state.count;
					const theta = y.slice(0, n);
					const omega = y.slice(n, 2 * n);
					const alpha = accelerations(theta, omega);
					return omega.concat(alpha);
				}

				// -------------------------------------------------------------
				// RK4 integration
				//
				// Uses a fixed-step RK4 with optional sub-stepping (in tick())
				// to keep the simulation stable under variable frame times.
				// -------------------------------------------------------------
				function rk4Step(y, dt) {
					covHit('rk4Step');
					const k1 = deriv(y);
					const y2 = y.map((v, i) => v + 0.5 * dt * k1[i]);
					const k2 = deriv(y2);
					const y3 = y.map((v, i) => v + 0.5 * dt * k2[i]);
					const k3 = deriv(y3);
					const y4 = y.map((v, i) => v + dt * k3[i]);
					const k4 = deriv(y4);
					return y.map((v, i) => {
						return (
							v +
							(dt / 6) *
								(k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i])
						);
					});
				}

				// =============================================================
				// Kinematics
				// =============================================================
				// Converts angles/velocities into Cartesian
				// positions and velocities.
				function forwardKinematics(pivot, theta, omega) {
					covHit('forwardKinematics');
					const n = theta.length;
					const p = new Array(n);
					const v = new Array(n);
					let prevP = { x: pivot.x, y: pivot.y };
					let prevV = { x: 0, y: 0 };

					for (let i = 0; i < n; i++) {
						const Li = params.lengths[i];
						const ti = theta[i];
						const wi = omega[i];

						const pi = {
							x: prevP.x + Li * Math.sin(ti),
							y: prevP.y + Li * Math.cos(ti),
						};

						const vRel = {
							x: Li * Math.cos(ti) * wi,
							y: -Li * Math.sin(ti) * wi,
						};

						const vi = { x: prevV.x + vRel.x, y: prevV.y + vRel.y };
						p[i] = pi;
						v[i] = vi;
						prevP = pi;
						prevV = vi;
					}

					return { p, v };
				}

				// =============================================================
				// Trails
				// =============================================================
				// Each bob has its own polyline of recent positions.
				// Trails are truncated to params.trailLen points.
				function clearTrails() {
					covHit('clearTrails');
					for (const t of trails) t.length = 0;
				}

				function pushTrail(index, point) {
					covHit('pushTrail');
					const arr = trails[index];
					arr.push(point);
					const extra = arr.length - params.trailLen;
					if (extra > 0) arr.splice(0, extra);
				}

				function drawTrail(points, hue) {
					covHit('drawTrail');
					if (points.length < 2) return;
					// Draw as one smoothed curve (no per-point "dots").
					ctx.lineCap = 'round';
					ctx.lineJoin = 'round';
					ctx.lineWidth = 2;
					ctx.strokeStyle = `hsla(${hue}, 85%, 72%, 0.35)`;
					ctx.beginPath();
					ctx.moveTo(points[0].x, points[0].y);
					if (points.length === 2) {
						ctx.lineTo(points[1].x, points[1].y);
						ctx.stroke();
						return;
					}

					for (let i = 1; i < points.length - 1; i++) {
						const p0 = points[i];
						const p1 = points[i + 1];
						const mx = (p0.x + p1.x) * 0.5;
						const my = (p0.y + p1.y) * 0.5;
						ctx.quadraticCurveTo(p0.x, p0.y, mx, my);
					}
					const last = points[points.length - 1];
					ctx.lineTo(last.x, last.y);
					ctx.stroke();
				}

				// =============================================================
				// Rendering
				// =============================================================
				// Rendering order each frame:
				// 1) background vignette
				// 2) trails
				// 3) ground shadows (all bobs)
				// 4) rod segments
				// 5) pivot cap + bobs
				function draw() {
					covHit('draw');
					const { pivot, bobRadius, w, h } = layout();
					ctx.clearRect(0, 0, w, h);

					// Canvas background (drawn, not CSS) so it scales with DPR.
					const bg = ctx.createLinearGradient(0, 0, 0, h);
					bg.addColorStop(0, 'rgba(255, 255, 255, 0.04)');
					bg.addColorStop(1, 'rgba(255, 255, 255, 0.015)');
					ctx.fillStyle = bg;
					ctx.fillRect(0, 0, w, h);

					const vignette = ctx.createRadialGradient(
						w * 0.5,
						h * 0.45,
						Math.min(w, h) * 0.1,
						w * 0.5,
						h * 0.45,
						Math.max(w, h) * 0.7
					);
					vignette.addColorStop(0, 'rgba(0,0,0,0)');
					vignette.addColorStop(1, 'rgba(0,0,0,0.35)');
					ctx.fillStyle = vignette;
					ctx.fillRect(0, 0, w, h);

					const { p: positions } = forwardKinematics(
						pivot,
						state.theta,
						state.omega
					);
					for (let i = 0; i < trails.length; i++) {
						drawTrail(trails[i], 200 + i * 35);
					}

					const lastR = bobRadius(positions.length - 1);
					const totalLen = params.lengths.reduce((a, b) => a + b, 0);
					let maxR = 0;
					for (let i = 0; i < positions.length; i++) {
						maxR = Math.max(maxR, bobRadius(i));
					}
					const groundY = pivot.y + totalLen + maxR * 0.9;

					// Ground shadows for all bobs.
					for (let i = 0; i < positions.length; i++) {
						const pos = positions[i];
						const r = bobRadius(i);
						const shadowW = r * 2.6;
						const shadowH = r * 0.68;
						const t =
							positions.length > 1
								? i / (positions.length - 1)
								: 1;
						const a0 = 0.08 + 0.20 * t;
						const shadow = ctx.createRadialGradient(
							pos.x,
							groundY,
							4,
							pos.x,
							groundY,
							shadowW
						);
						shadow.addColorStop(0, `rgba(0,0,0,${a0})`);
						shadow.addColorStop(1, 'rgba(0,0,0,0)');
						ctx.fillStyle = shadow;
						ctx.beginPath();
						ctx.ellipse(
							pos.x,
							groundY,
							shadowW,
							shadowH,
							0,
							0,
							TAU
						);
						ctx.fill();
					}

					ctx.lineCap = 'round';
					ctx.strokeStyle = 'rgba(240, 245, 255, 0.75)';
					ctx.lineWidth = Math.max(2, lastR * 0.16);
					ctx.beginPath();
					ctx.moveTo(pivot.x, pivot.y);
					for (let i = 0; i < positions.length; i++) {
						ctx.lineTo(positions[i].x, positions[i].y);
					}
					ctx.stroke();

					const capR = lastR * 0.22;
					const cap = ctx.createRadialGradient(
						pivot.x - capR * 0.25,
						pivot.y - capR * 0.25,
						1,
						pivot.x,
						pivot.y,
						capR * 1.6
					);
					cap.addColorStop(0, 'rgba(255,255,255,0.9)');
					cap.addColorStop(1, 'rgba(120,140,170,0.55)');
					ctx.fillStyle = cap;
					ctx.beginPath();
					ctx.arc(pivot.x, pivot.y, capR, 0, TAU);
					ctx.fill();
					ctx.strokeStyle = 'rgba(255,255,255,0.25)';
					ctx.lineWidth = 1;
					ctx.stroke();

					function drawBob(x, y, r, hue) {
						const gx = x - r * 0.35;
						const gy = y - r * 0.45;
						const grad = ctx.createRadialGradient(
							gx,
							gy,
							r * 0.2,
							x,
							y,
							r * 1.35
						);
						grad.addColorStop(0, 'rgba(255,255,255,0.95)');
						grad.addColorStop(0.18, `hsla(${hue}, 85%, 72%, 0.92)`);
						grad.addColorStop(0.55, 'rgba(120,150,190,0.75)');
						grad.addColorStop(1, 'rgba(35,55,85,0.88)');

						ctx.fillStyle = grad;
						ctx.beginPath();
						ctx.arc(x, y, r, 0, TAU);
						ctx.fill();

						ctx.strokeStyle = 'rgba(255,255,255,0.20)';
						ctx.lineWidth = 1;
						ctx.stroke();

						ctx.strokeStyle = 'rgba(255,255,255,0.10)';
						ctx.lineWidth = 2;
						ctx.beginPath();
						ctx.arc(x, y, r * 0.72, 0.2, 1.6);
						ctx.stroke();
					}

					for (let i = 0; i < positions.length; i++) {
						drawBob(
							positions[i].x,
							positions[i].y,
							bobRadius(i),
							200 + i * 35
						);
					}

					ctx.strokeStyle = 'rgba(255,255,255,0.06)';
					ctx.lineWidth = 1;
					ctx.beginPath();
					ctx.moveTo(w * 0.1, groundY + maxR * 0.85);
					ctx.lineTo(w * 0.9, groundY + maxR * 0.85);
					ctx.stroke();
				}

				// =============================================================
				// Interaction
				// =============================================================
				// Convert pointer coordinates into an angle
				// relative to a joint origin.
				function pointerToThetaFromPoint(clientX, clientY, origin) {
					covHit('pointerToThetaFromPoint');
					const rect = canvas.getBoundingClientRect();
					const x = clientX - rect.left;
					const y = clientY - rect.top;
					const dx = x - origin.x;
					const dy = y - origin.y;
					let theta = Math.atan2(dx, dy);
					theta = clamp(theta, -Math.PI * 0.95, Math.PI * 0.95);
					return theta;
				}

				// Returns the topmost bob index under the pointer,
				// or -1 if none.
				// Includes a small "click cushion" to make it easier to grab
				// a moving bob.
				function hitTest(clientX, clientY) {
					covHit('hitTest');
					const { pivot, bobRadius } = layout();
					const rect = canvas.getBoundingClientRect();
					const x = clientX - rect.left;
					const y = clientY - rect.top;
					const { p } = forwardKinematics(
						pivot,
						state.theta,
						state.omega
					);

					for (let i = p.length - 1; i >= 0; i--) {
						const dx = x - p[i].x;
						const dy = y - p[i].y;
						const r = bobRadius(i);
						// Click cushion: allow selecting slightly outside the
						// visible bob, to make grabbing moving bobs easier.
						const cushion = 14;
						const pickR = r * 1.4 + cushion;
						if (dx * dx + dy * dy <= pickR * pickR) return i;
					}
					return -1;
				}

				// -------------------------------------------------------------
				// Input affordance: "nudge" on empty click
				//
				// Adds a small random angular velocity to start motion.
				// Corner case: for N=1 we must not apply two impulses to the
				// same bob (first and last are the same index).
				// -------------------------------------------------------------
				function nudge() {
					covHit('nudge');
					if (state.count <= 0) return;
					if (state.count === 1) {
						state.omega[0] +=
							(Math.random() > 0.5 ? 1 : -1) * 0.28;
						return;
					}
					state.omega[0] += (Math.random() > 0.5 ? 1 : -1) * 0.18;
					state.omega[state.count - 1] +=
						(Math.random() > 0.5 ? 1 : -1) * 0.32;
				}

				canvas.addEventListener(
					'pointerdown',
					(e) => {
						e.preventDefault();
					// Some environments can throw on pointer capture.
					// It's optional here, so fail gracefully.
					try {
						canvas.setPointerCapture(e.pointerId);
					} catch {
						// no-op
					}
					const hit = hitTest(e.clientX, e.clientY);
					if (hit < 0) {
						nudge();
						return;
					}

					state.dragging = true;
					state.dragIndex = hit;
					clearTrails();

					const { pivot } = layout();
					const { p } = forwardKinematics(
						pivot,
						state.theta,
						state.omega
					);
					const origin = hit === 0 ? pivot : p[hit - 1];
					state.theta[hit] = pointerToThetaFromPoint(
						e.clientX,
						e.clientY,
						origin
					);
					state.omega[hit] = 0;
					},
					{ passive: false }
				);

				canvas.addEventListener(
					'pointermove',
					(e) => {
						if (!state.dragging) return;
						e.preventDefault();
					const { pivot } = layout();
					const { p } = forwardKinematics(
						pivot,
						state.theta,
						state.omega
					);
					const idx = clamp(state.dragIndex, 0, state.count - 1);
					const origin = idx === 0 ? pivot : p[idx - 1];
					state.theta[idx] = pointerToThetaFromPoint(
						e.clientX,
						e.clientY,
						origin
					);
					state.omega[idx] = 0;
					},
					{ passive: false }
				);

				function endDrag(e) {
					if (e && typeof e.preventDefault === 'function') e.preventDefault();
					state.dragging = false;
				}
				canvas.addEventListener('pointerup', endDrag, { passive: false });
				canvas.addEventListener('pointercancel', endDrag, { passive: false });
				canvas.addEventListener(
					'lostpointercapture',
					endDrag,
					{ passive: false }
				);

				// =============================================================
				// Stats panel
				// =============================================================
				// Builds a monospaced table including all bobs.
				// Notes:
				// - "selected" is the last dragged bob index.
				// - Energy numbers are display-only and use gEff.
				function updateStats(dtRaw) {
					covHit('updateStats');
					if (!statsText) return;
					const { pivot } = layout();
					const { p, v } = forwardKinematics(
						pivot,
						state.theta,
						state.omega
					);
					const gEff = params.g * 110;

					function span(cls, text) {
						return `<span class="${cls}">${text}</span>`;
					}

					function clsForSign(x) {
						if (!Number.isFinite(x)) return 'test-dim';
						if (x > 1e-6) return 'stat-pos';
						if (x < -1e-6) return 'stat-neg';
						return 'test-dim';
					}

					let ke = 0;
					let pe = 0;
					let maxSpeed = 0;
					for (let i = 0; i < state.count; i++) {
						const speed = Math.hypot(v[i].x, v[i].y);
						maxSpeed = Math.max(maxSpeed, speed);
						ke += 0.5 * params.masses[i] * speed * speed;
						const yUp = -(p[i].y - pivot.y);
						pe += params.masses[i] * gEff * yUp;
					}

					const lastIdx = state.count - 1;
					const idx = clamp(state.dragIndex, 0, lastIdx);

					let lines = '';
					lines += span(
						'stat-hdr',
						`N=${state.count}  selected=#${idx + 1}  ` +
							`gEff=${fmt(gEff, 0)}  ` +
							`dt=${fmt(dtRaw * 1000, 1)} ms`
					);
					lines += `\n\n`;
					{
						const hdrIdx = '#'.padEnd(3);
						const hdrT = 'T(s)'.padStart(6);
						const hdrF = 'f(Hz)'.padStart(6);
						const hdrTheta = 'th(deg)'.padStart(7);
						const hdrOmega = 'w(rad/s)'.padStart(9);
						const hdrV = '|v|(px/s)'.padStart(10);
						lines += span(
							'stat-hdr',
							`${hdrIdx}  ${hdrT}  ${hdrF}  ${hdrTheta}  ` +
								`${hdrOmega}  ${hdrV}`
						);
					}
					lines += `\n`;
					for (let i = 0; i < state.count; i++) {
						const deg = radToDeg(state.theta[i]);
						const speed = Math.hypot(v[i].x, v[i].y);
						const T = periodTrack.estT[i];
						const f = Number.isFinite(T) && T > 0 ? 1 / T : NaN;
						const mark = i === idx ? '*' : ' ';
						const colIdx = `${mark}${String(i + 1).padStart(2)}`;
						const colT = fmt(T, 2).padStart(6);
						const colF = fmt(f, 2).padStart(6);
						const colTheta = fmt(deg, 1).padStart(7);
						const colOmega = fmt(state.omega[i], 3).padStart(9);
						const colV = fmt(speed, 1).padStart(10);

						const idxCls = i === idx ? 'stat-sel' : 'test-dim';
						const tCls = clsForSign(deg);
						const wCls = clsForSign(state.omega[i]);
						let vCls = '';
						if (maxSpeed > 0) {
							const r = speed / maxSpeed;
							vCls = r >= 0.66 ? 'stat-pos' : r <= 0.33
								? 'test-dim'
								: '';
						}

						lines += span(idxCls, colIdx);
						lines += `  `;
						lines += span('test-dim', colT);
						lines += `  `;
						lines += span('test-dim', colF);
						lines += `  `;
						lines += span(tCls, colTheta);
						lines += `  `;
						lines += span(wCls, colOmega);
						lines += `  `;
						lines += vCls ? span(vCls, colV) : colV;
						lines += `\n`;
					}
					lines += `\n`;
					lines += span('stat-hdr', 'Energy (display units)');
					lines += `\n`;
					lines += `  `;
					lines += span('test-dim', 'KE=');
					lines += fmt(ke, 0);
					lines += `  `;
					lines += span('test-dim', 'PE=');
					lines += fmt(pe, 0);
					lines += `  `;
					lines += span('test-dim', 'E=');
					lines += fmt(ke + pe, 0);

					statsText.innerHTML = lines;
				}

				window.addEventListener('resize', () => {
					resizeCanvas();
					draw();
				});

				// =============================================================
				// Main loop
				// =============================================================
				// Advances simulation, updates trails, updates stats,
				// and draws.
				function tick(now) {
					covHit('tick');
					if (testsEnabled && testsRunning) {
						requestAnimationFrame(tick);
						return;
					}
					const dtRaw = (now - state.lastT) / 1000;
					state.lastT = now;

					if (!prefersReducedMotion && !state.dragging) {
						const dt = clamp(dtRaw, 0, 1 / 15);
						state.simTime += dt;
						const steps = Math.max(
							1,
							Math.ceil(dt / params.maxStep)
						);
						const h = dt / steps;

						for (let i = 0; i < steps; i++) {
							const n = state.count;
							const y = state.theta.concat(state.omega);
							const next = rk4Step(y, h);
							state.theta = next.slice(0, n);
							state.omega = next.slice(n, 2 * n);
							for (let k = 0; k < n; k++) {
								if (state.theta[k] > Math.PI) {
									state.theta[k] -= TAU;
								}
								if (state.theta[k] < -Math.PI) {
									state.theta[k] += TAU;
								}
							}
						}
					}

					if (!prefersReducedMotion && !state.dragging) {
						updatePeriodTracker(state.simTime);
					}

					if (!prefersReducedMotion) {
						const { pivot } = layout();
						const { p } = forwardKinematics(
							pivot,
							state.theta,
							state.omega
						);
						for (let i = 0; i < p.length; i++) {
							pushTrail(i, p[i]);
						}
					}

					updateStats(dtRaw);
					draw();
					requestAnimationFrame(tick);
				}

				// =============================================================
				// Inputs panel
				// =============================================================
				// Applies bob count + size overrides from the UI.
				// Parsing rules for Bobs:
				// - Integer clamped to [1,10].
				// - Missing/invalid value keeps the current N.
				// Parsing rules for Sizes:
				// - Comma/space separated list, in px.
				// - Missing entries fall back to auto (null).
				// - "auto" or "-" explicitly selects auto for that bob.
				function applyBobCountFromUI() {
					covHit('applyBobCountFromUI');
					const raw = (bobCountInput?.value ?? '').trim();
					const parsed = Number.parseInt(raw, 10);
					const n = Number.isFinite(parsed)
						? clamp(parsed, 1, 10)
						: state.count;
					setBobCount(n);

					const lenTextRaw = (bobLengthsInput?.value ?? '').trim();
					const lenTextLower = lenTextRaw.toLowerCase();
					if (lenTextLower.length === 0 || lenTextLower === 'auto') {
						params.lengthOverrides = new Array(state.count);
						params.lengthOverrides.fill(null);
					} else {
						const parts = lenTextRaw
							.split(/[\s,]+/)
							.map((s) => s.trim())
							.filter(Boolean);
						const next = new Array(state.count);
						for (let i = 0; i < state.count; i++) {
							const rawTok = parts[i];
							const tok = (rawTok ?? '').toLowerCase();
							if (!tok || tok === '-' || tok === 'auto') {
								next[i] = null;
								continue;
							}
							const v = Number(rawTok);
							if (Number.isFinite(v) && v > 0) {
								next[i] = clamp(v, 40, 420);
							} else {
								next[i] = null;
							}
						}
						params.lengthOverrides = next;
					}

					const text = (bobSizesInput?.value ?? '').trim();
					if (text.length === 0) {
						params.radiusOverrides = new Array(state.count);
						params.radiusOverrides.fill(null);
					} else {
						const parts = text
							.split(/[\s,]+/)
							.map((s) => s.trim())
							.filter(Boolean);
						const next = new Array(state.count).fill(null);
						const take = Math.min(parts.length, state.count);
						for (let i = 0; i < take; i++) {
							const token = parts[i].toLowerCase();
							if (token === 'auto' || token === '-') {
								next[i] = null;
								continue;
							}
							const r = Number.parseFloat(token);
							if (Number.isFinite(r) && r > 0) {
								next[i] = clamp(r, 6, 80);
							}
						}
						params.radiusOverrides = next;
					}

					clearTrails();
					state.dragging = false;
					state.dragIndex = clamp(
						state.dragIndex,
						0,
						state.count - 1
					);
					updateStats(0);
					draw();
					updateShareUrlFromInputs();
				}

				// Wire UI events.
				function applyInputsFromUI() {
					applyBobCountFromUI();
					setInputsCollapsed(true);
				}

				applyBobsBtn?.addEventListener('click', () => {
					applyInputsFromUI();
				});
				bobCountInput?.addEventListener('keydown', (e) => {
					if (e.key !== 'Enter') return;
					e.preventDefault();
					applyInputsFromUI();
				});
				bobSizesInput?.addEventListener('keydown', (e) => {
					if (e.key !== 'Enter') return;
					e.preventDefault();
					applyInputsFromUI();
				});
				bobLengthsInput?.addEventListener('keydown', (e) => {
					if (e.key !== 'Enter') return;
					e.preventDefault();
					applyInputsFromUI();
				});

				// =========================================================
				// Unit tests (optional)
				// =========================================================
				// This file is a self-contained demo, so the test harness is
				// also self-contained.
				//
				// Requirements:
				// - Tests panel only visible with ?tests=1.
				// - A Run button runs all tests and prints results.
				// - Normal use should not pay the test cost.
				if (testsEnabled && runTestsBtn && testsText) {
					const unitTests = [];
					let outHtml = '';

					function test(name, fn) {
						unitTests.push({
							num: unitTests.length + 1,
							name,
							fn,
						});
					}

					function escapeHtml(s) {
						return String(s)
							.replaceAll('&', '&amp;')
							.replaceAll('<', '&lt;')
							.replaceAll('>', '&gt;');
					}

					function fail(msg) {
						throw new Error(msg);
					}

					function assert(cond, msg = 'assertion failed') {
						if (!cond) fail(msg);
					}

					function eq(actual, expected, msg = 'not equal') {
						if (actual !== expected) {
							fail(`${msg}: ${actual} !== ${expected}`);
						}
					}

					function approx(actual, expected, eps = 1e-6) {
						const ok = Math.abs(actual - expected) <= eps;
						if (!ok) {
							fail(`approx: ${actual} !~= ${expected}`);
						}
					}

					function snapshot() {
						return {
							state: {
								count: state.count,
								theta: state.theta.slice(),
								omega: state.omega.slice(),
								dragging: state.dragging,
								dragIndex: state.dragIndex,
								lastT: state.lastT,
								simTime: state.simTime,
							},
							periodTrack: {
								lastOmega: periodTrack.lastOmega.slice(),
								lastPosPeakT: periodTrack.lastPosPeakT.slice(),
								lastNegPeakT: periodTrack.lastNegPeakT.slice(),
								estT: periodTrack.estT.slice(),
								lastSampleT: periodTrack.lastSampleT,
							},
							params: {
								g: params.g,
								lengths: params.lengths.slice(),
									lengthOverrides: params.lengthOverrides.slice(),
								masses: params.masses.slice(),
								damping: params.damping.slice(),
								radiusOverrides: params.radiusOverrides.slice(),
								maxStep: params.maxStep,
								trailLen: params.trailLen,
							},
							trails: trails.map((t) =>
								t.map((p) => ({ x: p.x, y: p.y }))
							),
						};
					}

					function restore(s) {
						state.count = s.state.count;
						state.theta = s.state.theta.slice();
						state.omega = s.state.omega.slice();
						state.dragging = s.state.dragging;
						state.dragIndex = s.state.dragIndex;
						state.lastT = s.state.lastT;
						state.simTime = s.state.simTime;
						if (s.periodTrack) {
							periodTrack.lastOmega = s.periodTrack.lastOmega.slice();
							periodTrack.lastPosPeakT =
								s.periodTrack.lastPosPeakT.slice();
							periodTrack.lastNegPeakT =
								s.periodTrack.lastNegPeakT.slice();
							periodTrack.estT = s.periodTrack.estT.slice();
							periodTrack.lastSampleT = s.periodTrack.lastSampleT;
						} else {
							resetPeriodTracker();
						}
						params.g = s.params.g;
						params.lengths = s.params.lengths.slice();
							params.lengthOverrides = s.params.lengthOverrides.slice();
						params.masses = s.params.masses.slice();
						params.damping = s.params.damping.slice();
						params.radiusOverrides =
							s.params.radiusOverrides.slice();
						params.maxStep = s.params.maxStep;
						params.trailLen = s.params.trailLen;
						trails = s.trails.map((t) =>
							t.map((p) => ({ x: p.x, y: p.y }))
						);
					}

					function showText(line) {
						outHtml += `${escapeHtml(line)}\n`;
						testsText.innerHTML = outHtml;
					}

					function showHtml(lineHtml) {
						outHtml += `${lineHtml}\n`;
						testsText.innerHTML = outHtml;
					}

					async function runAllTests() {
						runTestsBtn.disabled = true;
						testsRunning = true;
						covReset();
						// Ensure the main loop is counted in coverage.
						// RAF won't run until we yield, so invoke
						// tick() once under snapshot/restore.
						{
							const pre = snapshot();
							testsRunning = false;
							tick(performance.now());
							testsRunning = true;
							restore(pre);
						}
						const t0 = performance.now();
						let pass = 0;
						let failCount = 0;
						const numWidth = String(unitTests.length).length;
						outHtml = '';
						showText(`Running ${unitTests.length} tests...`);
						showText('');

						for (const tc of unitTests) {
							const num = String(tc.num).padStart(numWidth, '0');
							const snap = snapshot();
							const a0 = performance.now();
							try {
								const r = tc.fn();
								if (r && typeof r.then === 'function') await r;
								const ms = performance.now() - a0;
								pass++;
								showHtml(
									`<span class="test-dim">[${num}]</span> ` +
										`<span class="test-pass">[PASS]</span> ` +
										`${escapeHtml(tc.name)} ` +
										`<span class="test-dim">` +
											`(${fmt(ms, 1)} ms)</span>`
								);
							} catch (e) {
								const ms = performance.now() - a0;
								failCount++;
								showHtml(
									`<span class="test-dim">[${num}]</span> ` +
										`<span class="test-fail">[FAIL]</span> ` +
										`${escapeHtml(tc.name)} ` +
										`<span class="test-dim">` +
											`(${fmt(ms, 1)} ms)</span>`
								);
								showText(`  ${String(e?.message || e)}`);
							} finally {
								restore(snap);
							}
						}

						const totalMs = performance.now() - t0;
						showText('');
						showText(
							`Summary: ${pass}/${unitTests.length} passed, ` +
								`${failCount} failed ` +
								`(${fmt(totalMs, 1)} ms)`
						);

						if (cov) {
							const total = cov.keys.length;
							const hit = cov.keys.filter(
								(k) => (cov.hits[k] || 0) > 0
							);
							const pct = Math.round((hit.length / total) * 100);
							showText('');
							showText(
								`Coverage: ${hit.length}/${total} (${pct}%)`
							);
							for (const k of cov.keys) {
								const c = cov.hits[k] || 0;
								const cls = c > 0 ? 'test-pass' : 'test-fail';
								const tag = c > 0 ? 'HIT ' : 'MISS';
								showHtml(
									`<span class="${cls}">` +
										`[${tag}]</span> ` +
										`${escapeHtml(k)} ` +
										`<span class="test-dim">` +
											`(${c})</span>`
								);
							}
						}

						testsRunning = false;
						// After a run, focus the UI on the results.
						setInputsCollapsed(true);
						setStatsCollapsed(true);
						setTestsCollapsed(false);
						runTestsBtn.disabled = false;
					}

					// ---------------------
					// Test cases
					// ---------------------
					// Test case catalog (in order):
					//  1) HTML core elements exist: required DOM nodes exist.
					//  2) Panels start collapsed: startup UI is minimized.
					//  3) Collapsed content is display:none: CSS collapse works.
					//  4) Expand shows content: expanding restores display:block.
					//  5) Body overflow hidden: no scrollbars during use.
					//  6) Canvas has nonzero size: viewport layout is wired.
					//  7) Default bob sizes are 20,30,10: defaults stay stable.
					//  8) Default bob lengths are auto: defaults stay stable.
					//  9) resizeCanvas sets backing size: DPR sizing is applied.
					// 10) pointerToThetaFromPoint vertical is ~0: angle mapping.
					// 11) clamp clamps range: utility clamps endpoints.
					// 12) fmt prints finite and dash: formatting helper behavior.
					// 13) solveLinearSystem solves 2x2: numeric solver sanity.
					// 14) solveLinearSystem singular => zeros: fallback works.
					// 15) setBobCount clamps and resizes: arrays/trails resize.
					// 16) layout bobRadius uses overrides: clamps + auto sizing.
					// 17) forwardKinematics theta=0 points down: kinematics OK.
					// 18) pushTrail caps to trailLen: trail buffer keeps bound.
					// 19) applyBobCountFromUI parses sizes: "auto"/"-" => null.
					// 20) applyBobCountFromUI clamps size tokens: limits apply.
					// 21) invalid bob count keeps current N: blank input safe.
					// 22) nudge N=1 changes omega once: deterministic impulse.
					// 23) nudge N=2 changes both ends: deterministic impulse.
					// 24) hitTest finds last bob center: interaction picking.
					// 25) hitTest selects near bob edge: click cushion works.
					// 26) rk4Step returns finite vector: integration stable.
					// 27) setBobCount supports N=1..10: all counts are valid.
					// 28) setBobCount clamps out-of-range: 0->1 and 999->10.
					// 29) setBobCount ignores NaN/Infinity: keeps current N.
					// 30) applyBobCountFromUI sets all N=1..10 from input.
					// 31) applyBobCountFromUI sizes missing => auto for rest.
					// 32) applyBobCountFromUI sizes extra => ignored beyond N.
					// 33) applyBobCountFromUI sizes invalid => auto (null).
					// 34) applyBobCountFromUI parses whitespace separators.
					// 35) forwardKinematics straight down sums lengths.
					// 36) forwardKinematics right angle places first bob.
					// 37) applyBobCountFromUI clamps bobCount text inputs.
					// 38) Apply click collapses Inputs panel.
					// 39) Copyright footer exists and matches text.
					// 40) Hint is small and top-placed.
					// 41) applyBobCountFromUI parses lengths tokens.
					// 42) applyBobCountFromUI clamps lengths tokens.
					// 43) applyBobCountFromUI lengths invalid => auto.
					// 44) Wrap padding bottom stays small.
					// 45) Inputs toggle does not resize canvas.
					// 46) Stats toggle does not resize canvas.
					// 47) Toggle buttons show + and -.
					// 48) Enter key applies Inputs.
					// 49) Inputs stack stays above footer.
					// 50) Stats shows period and frequency.
					// 51) applyBobCountFromUI length tokens are case-insensitive.
					// 52) Period tracker estimates sine wave period.
					// 53) applyInputsFromQuery sets Inputs fields.
					// 54) URL params apply to state/overrides.
					// 55) Share URL preserves tests=1.
					// 56) Share URL clamps bobs.
					// 57) Share URL normalizes list tokens.
					test('HTML core elements exist', () => {
						assert(canvas instanceof HTMLCanvasElement);
						assert(inputsPanel);
						assert(statsPanel);
						assert(testsPanel);
						assert(bobLengthsInput);
						assert(!testsPanel.hidden);
					});

					test('Panels start collapsed', () => {
						assert(panelStartup);
						assert(panelStartup.inputsCollapsed);
						assert(panelStartup.statsCollapsed);
						assert(panelStartup.testsCollapsed);
					});

					test('Collapsed content is display:none', () => {
						const a = inputsPanel.querySelector('.content');
						const b = statsPanel.querySelector('.content');
						const c = testsPanel.querySelector('.content');
						setInputsCollapsed(true);
						setStatsCollapsed(true);
						setTestsCollapsed(true);
						eq(getComputedStyle(a).display, 'none');
						eq(getComputedStyle(b).display, 'none');
						eq(getComputedStyle(c).display, 'none');
					});

					test('Expand shows content', () => {
						const a = inputsPanel.querySelector('.content');
						setInputsCollapsed(false);
						eq(getComputedStyle(a).display, 'block');
					});

					test('Body overflow hidden', () => {
						eq(getComputedStyle(document.body).overflow, 'hidden');
					});

					test('Canvas has nonzero size', () => {
						const r = canvas.getBoundingClientRect();
						assert(r.width > 0 && r.height > 0);
					});

					test('Default bob sizes are 20,30,10', () => {
						assert(defaults);
						eq(defaults.bobCountAttr, '3');
						eq(defaults.bobSizesAttr, '20, 30, 10');
						eq(defaults.radiusOverrides[0], 20);
						eq(defaults.radiusOverrides[1], 30);
						eq(defaults.radiusOverrides[2], 10);
					});

					test('Default bob lengths are auto', () => {
						assert(defaults);
						eq(defaults.bobLengthsAttr, 'auto');
						for (const v of defaults.lengthOverrides) eq(v, null);
					});

					test('resizeCanvas sets backing size', () => {
						resizeCanvas();
						assert(canvas.width > 0);
						assert(canvas.height > 0);
					});

					test('pointerToThetaFromPoint vertical is ~0', () => {
						const L = layout();
						const rect = canvas.getBoundingClientRect();
						const cx = rect.left + L.pivot.x;
						const cy = rect.top + L.pivot.y + 100;
						const t = pointerToThetaFromPoint(
							cx,
							cy,
							L.pivot
						);
						approx(t, 0, 1e-6);
					});

					test('clamp clamps range', () => {
						eq(clamp(-1, 0, 2), 0);
						eq(clamp(3, 0, 2), 2);
						eq(clamp(1.5, 0, 2), 1.5);
					});

					test('fmt prints finite and dash', () => {
						eq(fmt(1.234, 2), '1.23');
						eq(fmt(NaN, 2), '—');
					});

					test('solveLinearSystem solves 2x2', () => {
						const A = [
							[2, 1],
							[1, 3],
						];
						const b = [1, 2];
						const x = solveLinearSystem(A, b);
						approx(x[0], 0.2, 1e-6);
						approx(x[1], 0.6, 1e-6);
					});

					test('solveLinearSystem singular => zeros', () => {
						const A = [
							[0, 0],
							[0, 0],
						];
						const b = [1, 2];
						const x = solveLinearSystem(A, b);
						eq(x[0], 0);
						eq(x[1], 0);
					});

					test('setBobCount clamps and resizes', () => {
						state.theta = [1, 2, 3];
						state.omega = [0.1, 0.2, 0.3];
						params.radiusOverrides = [10, 20, 30];
						state.dragIndex = 99;
						setBobCount(2);
						eq(state.count, 2);
						eq(state.theta.length, 2);
						eq(state.omega.length, 2);
						eq(state.theta[0], 1);
						eq(state.theta[1], 2);
						eq(state.omega[0], 0.1);
						eq(state.omega[1], 0.2);
						eq(params.radiusOverrides[0], 10);
						eq(params.radiusOverrides[1], 20);
						eq(trails.length, 2);
						eq(state.dragIndex, 1);
					});

					test('layout bobRadius uses overrides', () => {
						setBobCount(3);
						params.radiusOverrides = [999, null, 1];
						const L = layout();
						eq(L.bobRadius(0), 80);
						assert(L.bobRadius(1) >= 14);
						eq(L.bobRadius(2), 6);
					});

					test('forwardKinematics theta=0 points down', () => {
						setBobCount(1);
						state.theta[0] = 0;
						state.omega[0] = 0;
						const { pivot } = layout();
						const { p, v } = forwardKinematics(
							pivot,
							state.theta,
							state.omega
						);
						approx(p[0].x, pivot.x, 1e-6);
						assert(p[0].y > pivot.y);
						eq(v[0].x, 0);
						eq(v[0].y, 0);
					});

					test('pushTrail caps to trailLen', () => {
						setBobCount(1);
						params.trailLen = 3;
						clearTrails();
						for (let i = 0; i < 10; i++) {
							pushTrail(0, { x: i, y: i });
						}
						eq(trails[0].length, 3);
						eq(trails[0][0].x, 7);
					});

					test('applyBobCountFromUI parses sizes', () => {
						bobCountInput.value = '3';
						bobSizesInput.value = 'auto, 70, -';
						applyBobCountFromUI();
						eq(state.count, 3);
						eq(params.radiusOverrides[0], null);
						eq(params.radiusOverrides[1], 70);
						eq(params.radiusOverrides[2], null);
					});

					test('applyBobCountFromUI clamps size tokens', () => {
						bobCountInput.value = '3';
						bobSizesInput.value = '5, 999, x';
						applyBobCountFromUI();
						eq(params.radiusOverrides[0], 6);
						eq(params.radiusOverrides[1], 80);
						eq(params.radiusOverrides[2], null);
					});

					test('invalid bob count keeps current N', () => {
						setBobCount(4);
						bobCountInput.value = '   ';
						bobSizesInput.value = '10';
						applyBobCountFromUI();
						eq(state.count, 4);
					});

					test('nudge N=1 changes omega once', () => {
						const prevRand = Math.random;
						try {
							Math.random = () => 0.9;
							setBobCount(1);
							state.omega[0] = 0;
							nudge();
							approx(state.omega[0], 0.28, 1e-12);
						} finally {
							Math.random = prevRand;
						}
					});

					test('nudge N=2 changes both ends', () => {
						const prevRand = Math.random;
						try {
							Math.random = () => 0.9;
							setBobCount(2);
							state.omega[0] = 0;
							state.omega[1] = 0;
							nudge();
							approx(state.omega[0], 0.18, 1e-12);
							approx(state.omega[1], 0.32, 1e-12);
						} finally {
							Math.random = prevRand;
						}
					});

					test('hitTest finds last bob center', () => {
						setBobCount(2);
						state.theta[0] = 0.6;
						state.theta[1] = -0.2;
						state.omega[0] = 0;
						state.omega[1] = 0;
						const L = layout();
						const rect = canvas.getBoundingClientRect();
						const { p } = forwardKinematics(
							L.pivot,
							state.theta,
							state.omega
						);
						const last = p[p.length - 1];
						const cx = rect.left + last.x;
						const cy = rect.top + last.y;
						eq(hitTest(cx, cy), 1);
					});

					test('hitTest selects near bob edge', () => {
						setBobCount(2);
						state.theta[0] = 0.6;
						state.theta[1] = -0.2;
						state.omega[0] = 0;
						state.omega[1] = 0;
						const L = layout();
						const rect = canvas.getBoundingClientRect();
						const { p } = forwardKinematics(
							L.pivot,
							state.theta,
							state.omega
						);
						const i = 1;
						const pos = p[i];
						const r = L.bobRadius(i);
						// Click slightly outside the visible bob.
						const x = rect.left + pos.x + r + 8;
						const y = rect.top + pos.y;
						eq(hitTest(x, y), i);
					});

					test('rk4Step returns finite vector', () => {
						setBobCount(3);
						const n = state.count;
						const y = state.theta.concat(state.omega);
						const next = rk4Step(y, 1 / 120);
						eq(next.length, 2 * n);
						for (const v of next) assert(Number.isFinite(v));
					});

					test('setBobCount supports N=1..10', () => {
						for (let n = 1; n <= 10; n++) {
							setBobCount(n);
							eq(state.count, n);
							eq(state.theta.length, n);
							eq(state.omega.length, n);
							eq(params.lengths.length, n);
							eq(params.masses.length, n);
							eq(params.damping.length, n);
							eq(params.radiusOverrides.length, n);
							eq(trails.length, n);
						}
					});

					test('setBobCount clamps out-of-range', () => {
						setBobCount(0);
						eq(state.count, 1);
						setBobCount(999);
						eq(state.count, 10);
					});

					test('setBobCount ignores NaN/Infinity', () => {
						setBobCount(3);
						setBobCount(NaN);
						eq(state.count, 3);
						setBobCount(Infinity);
						eq(state.count, 3);
						setBobCount(-Infinity);
						eq(state.count, 3);
					});

					test('applyBobCountFromUI sets all N=1..10', () => {
						for (let n = 1; n <= 10; n++) {
							bobCountInput.value = String(n);
							bobSizesInput.value = '';
							applyBobCountFromUI();
							eq(state.count, n);
							eq(params.radiusOverrides.length, n);
							for (let i = 0; i < n; i++) {
								eq(params.radiusOverrides[i], null);
							}
						}
					});

					test('applyBobCountFromUI sizes missing => auto', () => {
						bobCountInput.value = '4';
						bobSizesInput.value = '10, 20';
						applyBobCountFromUI();
						eq(state.count, 4);
						eq(params.radiusOverrides[0], 10);
						eq(params.radiusOverrides[1], 20);
						eq(params.radiusOverrides[2], null);
						eq(params.radiusOverrides[3], null);
					});

					test('applyBobCountFromUI sizes extra => ignored', () => {
						bobCountInput.value = '2';
						bobSizesInput.value = '10, 20, 30, 40';
						applyBobCountFromUI();
						eq(state.count, 2);
						eq(params.radiusOverrides[0], 10);
						eq(params.radiusOverrides[1], 20);
					});

					test('applyBobCountFromUI sizes invalid => auto', () => {
						bobCountInput.value = '3';
						bobSizesInput.value = '0, -5, nope';
						applyBobCountFromUI();
						eq(state.count, 3);
						eq(params.radiusOverrides[0], null);
						eq(params.radiusOverrides[1], null);
						eq(params.radiusOverrides[2], null);
					});

					test('applyBobCountFromUI parses whitespace separators', () => {
						bobCountInput.value = '3';
						bobSizesInput.value = '6   7  8';
						applyBobCountFromUI();
						eq(state.count, 3);
						eq(params.radiusOverrides[0], 6);
						eq(params.radiusOverrides[1], 7);
						eq(params.radiusOverrides[2], 8);
					});

					test('forwardKinematics straight down sums lengths', () => {
						setBobCount(3);
						params.lengths = [100, 100, 100];
						const pivot = { x: 0, y: 0 };
						const theta = [0, 0, 0];
						const omega = [0, 0, 0];
						const { p } = forwardKinematics(pivot, theta, omega);
						eq(p.length, 3);
						approx(p[0].x, 0, 1e-12);
						approx(p[0].y, 100, 1e-12);
						approx(p[1].x, 0, 1e-12);
						approx(p[1].y, 200, 1e-12);
						approx(p[2].x, 0, 1e-12);
						approx(p[2].y, 300, 1e-12);
					});

					test('forwardKinematics right angle places first bob', () => {
						setBobCount(3);
						params.lengths = [100, 100, 100];
						const pivot = { x: 0, y: 0 };
						const theta = [Math.PI / 2, 0, 0];
						const omega = [0, 0, 0];
						const { p } = forwardKinematics(pivot, theta, omega);
						approx(p[0].x, 100, 1e-12);
						approx(p[0].y, 0, 1e-12);
						approx(p[1].x, 100, 1e-12);
						approx(p[1].y, 100, 1e-12);
						approx(p[2].x, 100, 1e-12);
						approx(p[2].y, 200, 1e-12);
					});

					test('applyBobCountFromUI clamps bobCount text inputs', () => {
						setBobCount(5);
						bobSizesInput.value = '';
						bobCountInput.value = '0';
						applyBobCountFromUI();
						eq(state.count, 1);

						bobCountInput.value = '999';
						applyBobCountFromUI();
						eq(state.count, 10);

						bobCountInput.value = '-3';
						applyBobCountFromUI();
						eq(state.count, 1);

						bobCountInput.value = '3.9';
						applyBobCountFromUI();
						eq(state.count, 3);

						bobCountInput.value = 'abc';
						applyBobCountFromUI();
						eq(state.count, 3);
					});

					test('Apply click collapses Inputs panel', () => {
						assert(inputsPanel);
						assert(applyBobsBtn);
						setInputsCollapsed(false);
						bobCountInput.value = '3';
						bobSizesInput.value = '';
						applyBobsBtn.click();
						assert(inputsPanel.classList.contains('is-collapsed'));
					});

					test('Copyright footer exists', () => {
						const el = document.getElementById('copyright');
						assert(el);
						eq(
							el.textContent.trim(),
							'(c) N-Bob Pendulum - Prabhu & GPT 5.2'
						);
						const cs = getComputedStyle(el);
						eq(cs.position, 'fixed');
						eq(cs.left, '12px');
						eq(cs.bottom, '6px');
					});

					test('Hint is small and top-placed', () => {
						const el = document.querySelector('.hint');
						assert(el);
						eq(el.textContent.trim(), 'Drag a bob. Click to nudge.');
						const cs = getComputedStyle(el);
						eq(cs.position, 'fixed');
						assert(cs.top !== 'auto');
						eq(cs.fontSize, '11px');
					});

					test('applyBobCountFromUI parses lengths tokens', () => {
						bobCountInput.value = '3';
						bobLengthsInput.value = 'auto, 250, -';
						bobSizesInput.value = '';
						applyBobCountFromUI();
						eq(state.count, 3);
						eq(params.lengthOverrides[0], null);
						eq(params.lengthOverrides[1], 250);
						eq(params.lengthOverrides[2], null);
					});

					test('applyBobCountFromUI clamps lengths tokens', () => {
						bobCountInput.value = '3';
						bobLengthsInput.value = '1, 999, 100';
						bobSizesInput.value = '';
						applyBobCountFromUI();
						eq(state.count, 3);
						eq(params.lengthOverrides[0], 40);
						eq(params.lengthOverrides[1], 420);
						eq(params.lengthOverrides[2], 100);
					});

					test('applyBobCountFromUI lengths invalid => auto', () => {
						bobCountInput.value = '3';
						bobLengthsInput.value = 'nope, 0, -5';
						bobSizesInput.value = '';
						applyBobCountFromUI();
						eq(state.count, 3);
						eq(params.lengthOverrides[0], null);
						eq(params.lengthOverrides[1], null);
						eq(params.lengthOverrides[2], null);
					});

					test('Wrap padding bottom stays small', () => {
						const el = document.querySelector('.wrap');
						assert(el);
						const cs = getComputedStyle(el);
						const pb = Number.parseFloat(cs.paddingBottom);
						assert(Number.isFinite(pb));
						// Padding is fixed; panels overlay the canvas.
						assert(pb >= 24);
						assert(pb <= 32);
					});

					test('Inputs toggle does not resize canvas', () => {
						const r0 = canvas.getBoundingClientRect();
						setInputsCollapsed(false);
						const r1 = canvas.getBoundingClientRect();
						setInputsCollapsed(true);
						const r2 = canvas.getBoundingClientRect();
						approx(r1.width, r0.width, 1e-6);
						approx(r1.height, r0.height, 1e-6);
						approx(r2.width, r0.width, 1e-6);
						approx(r2.height, r0.height, 1e-6);
					});

					test('Stats toggle does not resize canvas', () => {
						const r0 = canvas.getBoundingClientRect();
						setStatsCollapsed(false);
						const r1 = canvas.getBoundingClientRect();
						setStatsCollapsed(true);
						const r2 = canvas.getBoundingClientRect();
						approx(r1.width, r0.width, 1e-6);
						approx(r1.height, r0.height, 1e-6);
						approx(r2.width, r0.width, 1e-6);
						approx(r2.height, r0.height, 1e-6);
					});

					test('Toggle buttons show + and -', () => {
						assert(toggleInputsBtn);
						assert(toggleStatsBtn);
						eq(toggleInputsBtn.textContent.trim(), '+');
						eq(toggleStatsBtn.textContent.trim(), '+');
						setInputsCollapsed(false);
						setStatsCollapsed(false);
						eq(toggleInputsBtn.textContent.trim(), '−');
						eq(toggleStatsBtn.textContent.trim(), '−');
						if (testsEnabled && toggleTestsBtn && setTestsCollapsed) {
							setTestsCollapsed(true);
							eq(toggleTestsBtn.textContent.trim(), '+');
							setTestsCollapsed(false);
							eq(toggleTestsBtn.textContent.trim(), '−');
						}
					});

					test('Enter key applies Inputs', () => {
						assert(inputsPanel);
						assert(bobCountInput);
						assert(bobSizesInput);
						setInputsCollapsed(false);
						bobCountInput.value = '4';
						bobSizesInput.value = '';
						bobCountInput.dispatchEvent(
							new KeyboardEvent('keydown', {
								key: 'Enter',
								bubbles: true,
							})
						);
						eq(state.count, 4);
						assert(inputsPanel.classList.contains('is-collapsed'));
					});

					test('Inputs stack stays above footer', () => {
						const hud = document.querySelector('.hud-left');
						const foot = document.getElementById('copyright');
						assert(hud);
						assert(foot);
						const hb = Number.parseFloat(getComputedStyle(hud).bottom);
						const fb = Number.parseFloat(getComputedStyle(foot).bottom);
						assert(Number.isFinite(hb));
						assert(Number.isFinite(fb));
						assert(hb > fb);
					});

					test('Stats shows period and frequency', () => {
						assert(statsText);
						setBobCount(2);
						state.theta[0] = 0.5;
						state.theta[1] = -0.2;
						state.omega[0] = 2.0;
						state.omega[1] = -3.0;
						updateStats(1 / 60);
						const s = statsText.textContent || '';
						assert(s.includes('T(s)'));
						assert(s.includes('f(Hz)'));
					});

					test('applyBobCountFromUI length tokens are case-insensitive', () => {
						bobCountInput.value = '3';
						bobLengthsInput.value = 'AUTO, 250, -';
						bobSizesInput.value = '';
						applyBobCountFromUI();
						eq(state.count, 3);
						eq(params.lengthOverrides[0], null);
						eq(params.lengthOverrides[1], 250);
						eq(params.lengthOverrides[2], null);
					});

					test('Period tracker estimates sine wave period', () => {
						setBobCount(1);
						state.dragIndex = 0;
						resetPeriodTracker();
						state.simTime = 0;
						const w = 2.0;
						const expectedT = TAU / w;
						const dt = 0.01;
						for (let k = 0; k < 2000; k++) {
							const t = k * dt;
							state.theta[0] = Math.sin(w * t);
							state.omega[0] = w * Math.cos(w * t);
							updatePeriodTracker(t);
						}
						assert(Number.isFinite(periodTrack.estT[0]));
						approx(periodTrack.estT[0], expectedT, 0.03);
						approx(1 / periodTrack.estT[0], w / TAU, 0.01);
					});

					test('applyInputsFromQuery sets Inputs fields', () => {
						assert(bobCountInput);
						assert(bobSizesInput);
						assert(bobLengthsInput);
						bobCountInput.value = '3';
						bobSizesInput.value = '20,30,10';
						bobLengthsInput.value = 'auto';
						const qs = new URLSearchParams(
							'bobs=4&sizes=6 7 8 9&lengths=auto,250,-,200'
						);
						const changed = applyInputsFromQuery(qs);
						assert(changed);
						eq(bobCountInput.value, '4');
						eq(bobSizesInput.value, '6 7 8 9');
						eq(bobLengthsInput.value, 'auto,250,-,200');
					});

					test('URL params apply to state/overrides', () => {
						assert(bobCountInput);
						assert(bobSizesInput);
						assert(bobLengthsInput);
						const qs = new URLSearchParams(
							'bobs=4&sizes=6,7,auto,9&lengths=auto,250,-,200'
						);
						applyInputsFromQuery(qs);
						applyBobCountFromUI();
						eq(state.count, 4);
						eq(params.radiusOverrides[0], 6);
						eq(params.radiusOverrides[1], 7);
						eq(params.radiusOverrides[2], null);
						eq(params.radiusOverrides[3], 9);
						eq(params.lengthOverrides[0], null);
						eq(params.lengthOverrides[1], 250);
						eq(params.lengthOverrides[2], null);
						eq(params.lengthOverrides[3], 200);
					});

					test('Share URL preserves tests=1', () => {
						assert(shareUrlInput);
						bobCountInput.value = '3';
						bobSizesInput.value = '20,30,10';
						bobLengthsInput.value = 'auto';
						applyBobCountFromUI();
						const u = new URL(shareUrlInput.value);
						eq(u.searchParams.get('tests'), '1');
					});

					test('Share URL clamps bobs', () => {
						assert(shareUrlInput);
						bobCountInput.value = '999';
						bobSizesInput.value = '';
						bobLengthsInput.value = 'auto';
						applyBobCountFromUI();
						eq(state.count, 10);
						const u = new URL(shareUrlInput.value);
						eq(u.searchParams.get('bobs'), '10');
					});

					test('Share URL normalizes list tokens', () => {
						assert(shareUrlInput);
						bobCountInput.value = '4';
						bobSizesInput.value = 'AUTO 10 - 12';
						bobLengthsInput.value = 'auto, 250, -, 200';
						applyBobCountFromUI();
						const u = new URL(shareUrlInput.value);
						eq(u.searchParams.get('sizes'), 'auto,10,-,12');
						eq(u.searchParams.get('lengths'), 'auto,250,-,200');
					});

					testsText.textContent =
						'Ready. Click Run to execute tests.';
					runTestsBtn.addEventListener('click', () => {
						runAllTests();
					});
				}

				resizeCanvas();
				applyInputsFromQuery();
				applyBobCountFromUI();
				resetPeriodTracker();
				updateShareUrlFromInputs();
				draw();

				requestAnimationFrame((t) => {
					state.lastT = t;
					requestAnimationFrame(tick);
				});
			})();
		</script>
	</body>
</html>
