<!--
========================================================================
3D Dice Roller - Prabhu & GPT 5.2, Claude Opus 4.5
Version: 1.3

Description
------------------------------------------------------------------------
A self-contained HTML/CSS/JS dice (and coin) roller that supports face
counts from 2 to 20. It renders:
- D6 as a true CSS 3D cube with pip faces
- D2 as a golden 3D coin with Heads/Tails
- D3–D20 (except 6) as an extruded polygon silhouette with depth

Features
------------------------------------------------------------------------
- Click or press Space/Enter to roll; click mid-roll to restart
- Natural ease-out physics (monotone quartic) with early reveal (~70%)
- Responsive shadow, hover glow, and subtle idle animation
- Details tab (bottom-left) with:
    - Last 20 results and per-face distribution
    - Sound toggle (off by default)
    - Faces input (2–20) and a Heads/Tails hint for D2
- Confetti burst on max roll (e.g. 6 on D6, 20 on D20, Tails on D2)
- Optional WebAudio sound:
    - Dice: plastic-on-wood bounce/impact model
    - Coin: metallic tings + clinks + filtered noise
- Built-in unit tests (add `?tests=1` to the URL)
- Optional URL parameter: `?faces=<number>` sets the initial face count

Technical Details
------------------------------------------------------------------------
- CSS 3D transforms + RequestAnimationFrame animation
- No external dependencies; single-file HTML

How to Use
------------------------------------------------------------------------
1. Open in a browser
2. Click the die/coin or press Space/Enter to roll
3. Open Details to change Faces and view History/Distribution
4. (Optional) Enable sound in Details
5. Add `?faces=20` (or any 2–20) to set starting faces
6. Add `?tests=1` to run unit tests

========================================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Dice Roll</title>
    <style>
        /* ============================================================
           CSS Reset and Base Styles
           ============================================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Main body - medium gradient for white dice contrast */
        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(
                135deg,
                #2a3a5a 0%,
                #1e2e4e 50%,
                #1a2540 100%
            );
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        /* ============================================================
           3D Scene Container
           Sets up the perspective for 3D transforms
           ============================================================ */
        .scene {
            width: 200px;
            height: 200px;
            perspective: 800px;
            cursor: pointer;
            position: relative;
        }

        /* ============================================================
           Flat Die Display (used for 2-20 faces except 6)
           ============================================================ */
        .die2d {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            --die2d-rot: 0deg;
            --die2d-clip: none;
            border-radius: 32px;
            background: linear-gradient(
                135deg,
                #ffffff 0%,
                #f8f8f8 25%,
                #ececec 50%,
                #e0e0e0 75%,
                #d4d4d4 100%
            );
            border: 1px solid #c0c0c0;
            box-shadow:
                inset 3px 3px 8px rgba(255, 255, 255, 0.9),
                inset -1px -1px 6px rgba(255, 255, 255, 0.6),
                inset -8px -8px 16px rgba(0, 0, 0, 0.15),
                inset 8px 8px 16px rgba(0, 0, 0, 0.05),
                0 8px 20px rgba(0, 0, 0, 0.2);
            clip-path: var(--die2d-clip);
            transform:
                rotate(var(--die2d-rot))
                rotateX(12deg)
                rotateY(-12deg);
            transform-style: preserve-3d;
            transition: transform 0.1s ease-out;
        }

        .die2d::before {
            content: '';
            position: absolute;
            inset: 0;
            clip-path: var(--die2d-clip);
            background: linear-gradient(
                135deg,
                #d6d6d6 0%,
                #cfcfcf 25%,
                #c6c6c6 60%,
                #bdbdbd 100%
            );
            border: 1px solid rgba(0, 0, 0, 0.18);
            box-shadow:
                inset -6px -6px 14px rgba(0, 0, 0, 0.10),
                0 12px 18px rgba(0, 0, 0, 0.22);
            transform: translate(10px, 10px);
            z-index: -1;
        }

        .die2d.rolling {
            transition: none;
        }

        .die2d-value {
            font-size: 64px;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.85);
            line-height: 1;
        }

        .die2d-label {
            margin-top: 8px;
            font-size: 14px;
            letter-spacing: 1px;
            color: rgba(0, 0, 0, 0.55);
            font-weight: 600;
            text-transform: uppercase;
        }

        /* ============================================================
           Coin Display (used for 2 faces)
           ============================================================ */
        .coin {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            --coin-rot: 0deg;
            --coin-y: 0px;
            --coin-scale: 1;
            --coin-thickness: 24px;
            transform-style: preserve-3d;
            transform:
                translateY(var(--coin-y))
                scale(var(--coin-scale))
                rotateZ(8deg)
                rotateX(var(--coin-rot))
                rotateY(-20deg);
            transition: transform 0.1s ease-out;
        }

        .coin.rolling {
            transition: none;
        }

        /* Cylinder edge band (side wall) */
        .coin::before {
            content: '';
            position: absolute;
            left: 7%;
            top: 50%;
            width: 86%;
            height: var(--coin-thickness);
            border-radius: 999px;
            background:
                repeating-linear-gradient(
                    90deg,
                    rgba(255, 255, 255, 0.18) 0 2px,
                    rgba(0, 0, 0, 0.18) 2px 4px
                ),
                linear-gradient(
                    180deg,
                    rgba(80, 45, 0, 0.95),
                    rgba(255, 215, 0, 0.95),
                    rgba(120, 65, 0, 0.98)
                );
            box-shadow:
                0 16px 22px rgba(0, 0, 0, 0.24),
                inset 0 1px 0 rgba(255, 255, 255, 0.14),
                inset 0 -1px 0 rgba(0, 0, 0, 0.26);
            transform:
                translateY(-50%)
                rotateX(90deg);
            z-index: 0;
            backface-visibility: hidden;
        }

        .coin-face {
            position: absolute;
            inset: 7%;
            width: 86%;
            height: 86%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            backface-visibility: hidden;
            z-index: 2;
            border: 1px solid rgba(115, 70, 0, 0.55);
            background:
                radial-gradient(
                    circle at 32% 28%,
                    rgba(255, 255, 255, 0.72) 0%,
                    rgba(255, 215, 0, 0.98) 30%,
                    rgba(205, 135, 0, 0.98) 62%,
                    rgba(125, 70, 0, 0.98) 100%
                ),
                conic-gradient(
                    from 210deg,
                    rgba(255, 255, 255, 0.08),
                    rgba(0, 0, 0, 0.10),
                    rgba(255, 255, 255, 0.10)
                );
            box-shadow:
                inset 16px 16px 26px rgba(255, 255, 255, 0.12),
                inset -18px -18px 28px rgba(0, 0, 0, 0.30),
                inset 0 0 0 2px rgba(255, 255, 255, 0.08);
        }

        .coin-face::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background:
                radial-gradient(
                    circle at center,
                    transparent 0 56%,
                    rgba(255, 255, 255, 0.16) 56% 60%,
                    rgba(0, 0, 0, 0.20) 60% 64%,
                    transparent 64% 100%
                ),
                repeating-conic-gradient(
                    from 0deg,
                    rgba(255, 255, 255, 0.18) 0 2deg,
                    rgba(0, 0, 0, 0.16) 2deg 4deg
                );
            opacity: 0.55;
            pointer-events: none;
        }

        .coin-face::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background:
                repeating-linear-gradient(
                    18deg,
                    rgba(255, 255, 255, 0.06) 0 1px,
                    rgba(255, 255, 255, 0.00) 1px 6px
                );
            opacity: 0.45;
            pointer-events: none;
        }

        .coin-front {
            transform: translateZ(calc(var(--coin-thickness) / 2));
        }

        .coin-back {
            transform: rotateX(180deg) translateZ(calc(var(--coin-thickness) / 2));
        }

        .coin-mark {
            width: 70%;
            height: 70%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 78px;
            font-weight: 900;
            letter-spacing: 0;
            text-transform: uppercase;
            color: rgba(78, 44, 0, 0.90);
            background:
                radial-gradient(
                    circle at 30% 30%,
                    rgba(255, 255, 255, 0.18) 0%,
                    rgba(0, 0, 0, 0.06) 60%,
                    rgba(0, 0, 0, 0.18) 100%
                ),
                radial-gradient(
                    circle at 70% 75%,
                    rgba(255, 255, 255, 0.08) 0%,
                    rgba(255, 255, 255, 0.00) 55%
                );
            text-shadow:
                /* embossed/engraved feel */
                -1px -1px 0 rgba(255, 255, 255, 0.30),
                1px 1px 0 rgba(0, 0, 0, 0.36),
                1px 0 0 rgba(0, 0, 0, 0.18),
                -1px 0 0 rgba(0, 0, 0, 0.18),
                0 1px 0 rgba(0, 0, 0, 0.16),
                0 -1px 0 rgba(255, 255, 255, 0.10),
                0 3px 4px rgba(0, 0, 0, 0.18);
            box-shadow:
                inset 10px 10px 16px rgba(255, 255, 255, 0.12),
                inset -12px -12px 18px rgba(0, 0, 0, 0.26),
                inset 0 0 0 2px rgba(0, 0, 0, 0.12),
                inset 0 0 0 6px rgba(255, 255, 255, 0.05);
            line-height: 1;
        }

        /* The glyph 'T' has thinner strokes than 'H' in many fonts.
           Bump size slightly so it reads equally “embossed”. */
        .coin-back .coin-mark {
            font-size: 86px;
            color: rgba(35, 18, 0, 0.96);
        }

        /* ============================================================
           Dice Cube Container
           preserve-3d allows children to exist in 3D space
           ============================================================ */
        .dice {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(-25deg) rotateY(25deg);
            transition: transform 0.1s ease-out;
        }

        /* Remove transition during roll for smooth animation */
        .dice.rolling {
            transition: none;
        }

        /* ============================================================
           Dice Face Styling
           Clean white faces with subtle depth
           ============================================================ */
        .face {
            position: absolute;
            width: 200px;
            height: 200px;
            /* 3D gradient - light from top-left, darker bottom-right */
            background: linear-gradient(135deg, 
                #ffffff 0%,
                #f8f8f8 25%,
                #ececec 50%,
                #e0e0e0 75%,
                #d4d4d4 100%);
            /* Subtle border for definition */
            border: 1px solid #c0c0c0;
            /* More rounded for softer appearance */
            border-radius: 32px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 25px;
            /* Enhanced 3D depth with directional shadows */
            box-shadow:
                /* Top-left highlight (light source) */
                inset 3px 3px 8px rgba(255, 255, 255, 0.9),
                inset -1px -1px 6px rgba(255, 255, 255, 0.6),
                /* Bottom-right shadow (away from light) */
                inset -8px -8px 16px rgba(0, 0, 0, 0.15),
                inset 8px 8px 16px rgba(0, 0, 0, 0.05),
                /* Outer shadow for depth */
                0 8px 20px rgba(0, 0, 0, 0.2);
        }

        /* ============================================================
           Pip (Dot) Styling
           3D semi-spheres that cave INTO the dice surface
           Each face has unique random colors via CSS variables
           ============================================================ */
        .pip {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            /* Dynamic gradient using CSS variables */
            /* Colors set by JavaScript on page load */
            background: radial-gradient(
                circle at 30% 30%,
                var(--pip-color-light) 0%,
                var(--pip-color-mid) 30%,
                var(--pip-color-dark) 60%,
                var(--pip-color-darkest) 100%
            );
            /* Enhanced deep cavity effect with multiple shadow layers */
            box-shadow:
                /* Very deep inset shadows for pronounced cavity */
                inset 4px 4px 10px var(--pip-shadow-dark),
                inset 7px 7px 18px var(--pip-shadow-mid),
                inset 2px 2px 5px var(--pip-shadow-extra),
                /* Strong highlight where light reaches cavity edge */
                inset -3px -3px 8px var(--pip-highlight),
                inset -1px -1px 3px var(--pip-highlight-bright),
                /* Outer rim shadow for crisp edge definition */
                0 1px 3px var(--pip-shadow-outer),
                0 2px 5px var(--pip-shadow-outer);
            /* Subtle border enhances the carved-in effect */
            border: 0.5px solid var(--pip-border);
        }

        /* ============================================================
           Face 1 - Front (Single pip in center)
           ============================================================ */
        .face-1 {
            transform: translateZ(100px);
        }
        .face-1 .pip-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        /* ============================================================
           Face 2 - Back (Diagonal arrangement)
           ============================================================ */
        .face-2 {
            transform: rotateY(180deg) translateZ(100px);
        }
        .face-2 .pip-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            place-items: center;
        }
        .face-2 .pip:nth-child(1) {
            grid-column: 1;
            grid-row: 1;
        }
        .face-2 .pip:nth-child(2) {
            grid-column: 3;
            grid-row: 3;
        }

        /* ============================================================
           Face 3 - Right (Diagonal with center pip)
           ============================================================ */
        .face-3 {
            transform: rotateY(90deg) translateZ(100px);
        }
        .face-3 .pip-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            place-items: center;
        }
        .face-3 .pip:nth-child(1) {
            grid-column: 1;
            grid-row: 1;
        }
        .face-3 .pip:nth-child(2) {
            grid-column: 2;
            grid-row: 2;
        }
        .face-3 .pip:nth-child(3) {
            grid-column: 3;
            grid-row: 3;
        }

        /* ============================================================
           Face 4 - Left (2x2 grid arrangement)
           ============================================================ */
        .face-4 {
            transform: rotateY(-90deg) translateZ(100px);
        }
        .face-4 .pip-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            place-items: center;
        }
        .face-4 .pip:nth-child(1) {
            grid-column: 1;
            grid-row: 1;
        }
        .face-4 .pip:nth-child(2) {
            grid-column: 3;
            grid-row: 1;
        }
        .face-4 .pip:nth-child(3) {
            grid-column: 1;
            grid-row: 3;
        }
        .face-4 .pip:nth-child(4) {
            grid-column: 3;
            grid-row: 3;
        }

        /* ============================================================
           Face 5 - Top (X pattern with center pip)
           ============================================================ */
        .face-5 {
            transform: rotateX(90deg) translateZ(100px);
        }
        .face-5 .pip-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            place-items: center;
        }
        /* Position pips in X pattern with center */
        .face-5 .pip:nth-child(1) {
            grid-column: 1;
            grid-row: 1;
        }
        .face-5 .pip:nth-child(2) {
            grid-column: 3;
            grid-row: 1;
        }
        .face-5 .pip:nth-child(3) {
            grid-column: 2;
            grid-row: 2;
        }
        .face-5 .pip:nth-child(4) {
            grid-column: 1;
            grid-row: 3;
        }
        .face-5 .pip:nth-child(5) {
            grid-column: 3;
            grid-row: 3;
        }

        /* ============================================================
           Face 6 - Bottom (2x3 grid arrangement)
           ============================================================ */
        .face-6 {
            transform: rotateX(-90deg) translateZ(100px);
        }
        .face-6 .pip-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            place-items: center;
        }
        .face-6 .pip:nth-child(1) {
            grid-column: 1;
            grid-row: 1;
        }
        .face-6 .pip:nth-child(2) {
            grid-column: 1;
            grid-row: 2;
        }
        .face-6 .pip:nth-child(3) {
            grid-column: 1;
            grid-row: 3;
        }
        .face-6 .pip:nth-child(4) {
            grid-column: 3;
            grid-row: 1;
        }
        .face-6 .pip:nth-child(5) {
            grid-column: 3;
            grid-row: 2;
        }
        .face-6 .pip:nth-child(6) {
            grid-column: 3;
            grid-row: 3;
        }

        /* ============================================================
           Shadow Element
           Elliptical shadow beneath dice for grounding
           ============================================================ */
        .shadow {
            width: 180px;
            height: 40px;
            background: radial-gradient(
                ellipse,
                rgba(0, 0, 0, 0.5) 0%,
                transparent 70%
            );
            margin-top: 80px;
            border-radius: 50%;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }

        /* Shadow expands and fades during roll */
        .shadow.rolling {
            transform: scale(1.3);
            opacity: 0.3;
        }

        /* ============================================================
           UI Elements - Instructions and Result Display
           ============================================================ */
        .instructions {
            margin-top: 40px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .face-count-control {
            margin-top: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: rgba(255, 255, 255, 0.75);
            font-size: 14px;
            user-select: none;
        }

        .face-count-hint {
            color: rgba(255, 215, 0, 0.70);
            font-size: 12px;
            white-space: nowrap;
        }

        .face-count-control input {
            width: 84px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            background: rgba(0, 0, 0, 0.18);
            color: rgba(255, 255, 255, 0.9);
            outline: none;
        }

        .face-count-control input:focus {
            border-color: rgba(255, 215, 0, 0.7);
        }

        .face-count-control input[aria-invalid="true"],
        .face-count-control input[aria-invalid="true"]:focus {
            border-color: rgba(255, 70, 70, 0.95);
            box-shadow: 0 0 0 2px rgba(255, 70, 70, 0.25);
        }

        /* Golden result number display - instant appearance, no layout shift */
        .result {
            margin-top: 20px;
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow:
                0 0 20px rgba(255, 215, 0, 0.5),
                0 4px 8px rgba(0, 0, 0, 0.3);
            /* Fixed height prevents layout shift when text appears */
            height: 58px;
            line-height: 58px;
            /* Visibility instead of opacity - no transition delay */
            visibility: hidden;
        }

        .result.show {
            visibility: visible;
        }

        /* ============================================================
           Footer / Copyright Notice
           ============================================================ */
        .footnote {
            position: fixed;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.35);
            font-size: 11px;
            text-align: center;
            pointer-events: none;
            user-select: none;
        }

        /* ============================================================
           Hover Effect - Golden glow on white dice
           ============================================================ */
        .scene:hover .face {
            box-shadow:
                /* Keep subtle inner highlight */
                inset 0 0 20px rgba(255, 255, 255, 0.5),
                inset -5px -5px 15px rgba(255, 255, 255, 0.8),
                inset 5px 5px 15px rgba(220, 220, 220, 0.4),
                /* Add golden outer glow on hover */
                0 0 30px rgba(255, 215, 0, 0.4),
                0 0 50px rgba(255, 215, 0, 0.2),
                0 6px 15px rgba(0, 0, 0, 0.15);
        }

        /* ============================================================
           Unit Tests Tab (bottom-right)
           Single button "Run Tests"; expands to show results + summary
           ============================================================ */
        .test-tab {
            position: fixed;
            right: 12px;
            bottom: 12px;
            z-index: 1000;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            padding: 10px;
            width: 140px;
            /* Keep collapsed header fully visible (prevents button clipping) */
            max-height: 68px;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            font-family: monospace;
        }

        .test-tab.expanded {
            width: min(380px, calc(100vw - 24px));
            max-height: min(60vh, 520px);
            overflow: hidden;
        }

        .test-tab-header {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
        }

        .test-run-btn {
            flex: 1;
            min-width: 0;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
            font-weight: bold;
            line-height: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .test-toggle-btn {
            display: inline-block;
            width: 40px;
            background: rgba(255, 255, 255, 0.12);
            color: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 10px 0;
            border-radius: 8px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            white-space: nowrap;
        }

        .test-tab.expanded .test-toggle-btn {
            display: inline-block;
        }

        .test-run-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .test-results {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.12);
            max-height: calc(min(60vh, 520px) - 110px);
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.35;
        }

        .test-summary {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.12);
            font-size: 12px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
        }

        .test-tab.expanded .test-results,
        .test-tab.expanded .test-summary {
            display: block;
        }

        .test-pass {
            color: #3fb950;
            padding: 2px 0;
        }

        .test-fail {
            color: #f85149;
            padding: 2px 0;
        }

        .test-number {
            display: inline-block;
            min-width: 34px;
            color: rgba(255, 255, 255, 0.45);
            font-weight: normal;
        }

        .test-summary.all-passed {
            color: #3fb950;
        }

        .test-summary.has-failures {
            color: #f85149;
        }

        .test-coverage {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.12);
            font-size: 12px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.35;
        }

        .test-coverage-title {
            font-weight: bold;
            margin-bottom: 6px;
            color: rgba(255, 255, 255, 0.95);
        }

        .test-coverage-item {
            color: rgba(255, 255, 255, 0.85);
            padding: 1px 0;
        }

        @media (max-width: 480px) {
            .test-tab {
                right: 8px;
                bottom: 8px;
                /* Larger button padding/font on mobile needs more
                   collapsed room */
                max-height: 78px;
            }

            .test-tab.expanded {
                width: calc(100vw - 16px);
            }

            .test-run-btn {
                font-size: 13px;
                padding: 12px 12px;
            }

            .test-results,
            .test-summary {
                font-size: 13px;
            }
        }

        /* ============================================================
           History Tab (bottom-left corner)
           Shows roll history, count, and statistics
           ============================================================ */
        .history-tab {
            position: fixed;
            left: 12px;
            bottom: 12px;
            z-index: 999;
            background: rgba(30, 25, 40, 0.95);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
            width: 100px;
            max-height: 44px;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            font-family: 'Segoe UI', Tahoma, sans-serif;
            transition: max-height 0.2s ease-out, width 0.2s ease-out;
        }

        .history-tab.expanded {
            width: min(280px, calc(100vw - 24px));
            height: min(50vh, 400px);
            max-width: calc(100vw - 24px);
            max-height: calc(100vh - 24px);
            min-width: 220px;
            min-height: 180px;
            resize: both;
            display: flex;
            flex-direction: column;
        }

        .history-tab-header {
            display: flex;
            gap: 6px;
            align-items: center;
            cursor: pointer;
        }

        .history-title {
            flex: 1;
            color: #ffd700;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
        }

        .history-toggle-btn {
            width: 24px;
            height: 24px;
            background: rgba(255, 215, 0, 0.15);
            color: #ffd700;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            line-height: 1;
        }

        .history-content {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 215, 0, 0.15);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }

        .history-tab.expanded .history-content {
            display: block;
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            padding-right: 10px;
            scrollbar-gutter: stable;
            scrollbar-width: thin;
            scrollbar-color:
                rgba(255, 215, 0, 0.28)
                rgba(0, 0, 0, 0.25);
        }

        .history-tab.expanded .history-content::-webkit-scrollbar {
            width: 6px;
        }

        .history-tab.expanded .history-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.25);
            border-radius: 10px;
        }

        .history-tab.expanded .history-content::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.22);
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.22);
        }

        .history-tab.expanded .history-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.30);
        }

        .history-content .face-count-control {
            margin-top: 0;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.86);
        }

        .history-content .face-count-control input {
            width: 78px;
        }

        .history-content .face-count-control input::-webkit-inner-spin-button,
        .history-content .face-count-control input::-webkit-outer-spin-button {
            opacity: 0.95;
            background: rgba(255, 215, 0, 0.22);
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.22);
        }

        .history-content .face-count-control input::-webkit-inner-spin-button:hover,
        .history-content .face-count-control input::-webkit-outer-spin-button:hover {
            background: rgba(255, 215, 0, 0.30);
        }

        .history-sound-toggle {
            white-space: nowrap;
        }

        .history-section {
            margin-bottom: 12px;
        }

        .history-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .history-row-title {
            color: rgba(255, 215, 0, 0.8);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .history-section-title {
            color: rgba(255, 215, 0, 0.8);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .history-rolls {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .history-roll-item {
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffd700;
            font-weight: bold;
            font-size: 12px;
        }

        .history-stat {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            color: rgba(255, 255, 255, 0.85);
        }

        .history-stat-value {
            color: #ffd700;
            font-weight: bold;
        }

        .history-bar-container {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 3px 0;
        }

        .history-bar-label {
            width: 16px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
        }

        .history-bar {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .history-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffaa00);
            border-radius: 3px;
            transition: width 0.3s ease-out, filter 0.2s ease-out;
        }

        .history-bar-fill.dist-ok {
            filter: saturate(1.10) brightness(1.02);
        }

        .history-bar-fill.dist-good {
            filter: hue-rotate(80deg) saturate(1.15) brightness(1.00);
        }

        .history-bar-fill.dist-bad {
            filter: hue-rotate(-95deg) saturate(1.10) brightness(0.98);
        }

        .history-bar-percent {
            width: 36px;
            text-align: right;
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
        }

        .history-empty {
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            text-align: center;
            padding: 8px 0;
        }

        .history-sound-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255, 255, 255, 0.85);
            user-select: none;
        }

        .history-sound-toggle input {
            accent-color: #ffd700;
        }

        /* ============================================================
           Confetti Burst (shown when rolling a 6)
           ============================================================ */
        #confettiLayer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 50;
        }

        .confetti {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 6px;
            height: 10px;
            background: var(--confetti-color);
            border-radius: 2px;
            opacity: 1;
            transform: translate(-50%, -50%);
            will-change: transform, opacity;
        }

        @media (max-width: 480px) {
            .history-tab {
                left: 8px;
                bottom: 8px;
            }

            .history-tab.expanded {
                width: calc(100vw - 16px);
                max-width: calc(100vw - 16px);
                max-height: calc(100vh - 16px);
            }
        }
    </style>
</head>
<body>
    <!-- ================================================================
         Main Dice Scene
         The scene provides perspective, dice is the 3D cube
         ================================================================ -->
    <div class="scene" id="scene">
        <div class="dice" id="dice">
            <!-- Face 1: Single center pip -->
            <div class="face face-1">
                <div class="pip-container">
                    <div class="pip"></div>
                </div>
            </div>

            <!-- Face 2: Two diagonal pips -->
            <div class="face face-2">
                <div class="pip-container">
                    <div class="pip"></div>
                    <div class="pip"></div>
                </div>
            </div>

            <!-- Face 3: Three diagonal pips -->
            <div class="face face-3">
                <div class="pip-container">
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                </div>
            </div>

            <!-- Face 4: Four corner pips -->
            <div class="face face-4">
                <div class="pip-container">
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                </div>
            </div>

            <!-- Face 5: Five pips in X pattern -->
            <div class="face face-5">
                <div class="pip-container">
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                </div>
            </div>

            <!-- Face 6: Six pips in 2x3 grid -->
            <div class="face face-6">
                <div class="pip-container">
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                    <div class="pip"></div>
                </div>
            </div>
        </div>

        <div class="die2d" id="die2d" aria-hidden="true">
            <div class="die2d-value" id="die2dValue">6</div>
            <div class="die2d-label" id="die2dLabel">D6</div>
        </div>

        <div class="coin" id="coin" aria-hidden="true">
            <div class="coin-face coin-front">
                <div class="coin-mark">H</div>
            </div>
            <div class="coin-face coin-back">
                <div class="coin-mark">T</div>
            </div>
        </div>
    </div>

    <!-- Shadow element for grounding effect -->
    <div class="shadow" id="shadow"></div>

    <!-- User instructions -->
    <p class="instructions">Click the dice to roll!</p>

    <div class="face-count-control" id="faceCountControl">
        <label for="faceCount">Faces:</label>
        <span class="face-count-hint" id="faceCountHint"></span>
        <input
            type="number"
            id="faceCount"
            min="2"
            max="20"
            step="1"
            value="6"
        >
    </div>

    <!-- Result display (hidden until roll completes) -->
    <div class="result" id="result"></div>

    <!-- Confetti overlay (used when rolling the max value) -->
    <div id="confettiLayer" aria-hidden="true"></div>

    <!-- Copyright footnote -->
    <div class="footnote">(c) Dice - Prabhu & AIs</div>

    <script>
        // ================================================================
        // Random Pip Color Generation
        // Generates a random color for pips on each page load
        // ================================================================
        
        /**
         * Generate random pip colors based on a random hue
         * Returns a palette of lighter HSL shades for softer appearance
         * @returns {Object} Color values for CSS variables
         *   (hue, light, mid, dark, etc.)
         */
        function generateRandomPipColors() {
            // Random hue (0-360 degrees)
            const hue = Math.floor(Math.random() * 360);
            
            // Store for testing
            window.pipColorHue = hue;
            
            // Generate lighter color shades using HSL
            // Higher lightness values for softer, lighter colors
            const saturation = 40 + Math.random() * 35;
            
            return {
                hue: hue,
                saturation: saturation,
                light: `hsl(${hue}, ${saturation}%, 55%)`,      // Much lighter
                mid: `hsl(${hue}, ${saturation}%, 45%)`,
                dark: `hsl(${hue}, ${saturation}%, 35%)`,
                darkest: `hsl(${hue}, ${saturation}%, 25%)`,
                shadowDark: `hsla(${hue}, ${saturation}%, 15%, 0.95)`,
                shadowMid: `hsla(${hue}, ${saturation}%, 20%, 0.75)`,
                shadowExtra: `hsla(${hue}, ${saturation}%, 10%, 0.85)`,
                highlight: `hsla(${hue}, ${saturation}%, 90%, 0.4)`,
                highlightBright: `hsla(${hue}, ${saturation}%, 95%, 0.6)`,
                shadowOuter: `hsla(${hue}, ${saturation}%, 10%, 0.5)`,
                border: `hsla(${hue}, ${saturation}%, 20%, 0.4)`
            };
        }

        // Back-compat for unit tests: store one "current" palette and
        // set root vars.
        // Faces will override these with unique per-face palettes.
        function applyRootPipColors(colors) {
            const root = document.documentElement;
            root.style.setProperty('--pip-color-light', colors.light);
            root.style.setProperty('--pip-color-mid', colors.mid);
            root.style.setProperty('--pip-color-dark', colors.dark);
            root.style.setProperty('--pip-color-darkest', colors.darkest);
            root.style.setProperty('--pip-shadow-dark', colors.shadowDark);
            root.style.setProperty('--pip-shadow-mid', colors.shadowMid);
            root.style.setProperty('--pip-shadow-extra', colors.shadowExtra);
            root.style.setProperty('--pip-highlight', colors.highlight);
            root.style.setProperty(
                '--pip-highlight-bright',
                colors.highlightBright
            );
            root.style.setProperty('--pip-shadow-outer', colors.shadowOuter);
            root.style.setProperty('--pip-border', colors.border);
        }

        window.currentPipColors = generateRandomPipColors();
        applyRootPipColors(window.currentPipColors);
        
        // Store pip colors for each face for testing
        window.faceColors = {};
        
        // Generate unique colors for each face - no duplicates
        // Track used hues to prevent same color appearing twice
        const usedHues = new Set();
        const MIN_HUE_DIFFERENCE = 30; // Minimum degrees apart for
                           // distinct colors
        
        // Generate different random colors for each face (1-6)
        for (let faceNum = 1; faceNum <= 6; faceNum++) {
            let pipColors;
            let attempts = 0;
            const maxAttempts = 100;
            
            // Keep generating until we get a unique hue
            do {
                pipColors = generateRandomPipColors();
                attempts++;
                
                // Check if this hue is too close to any used hue
                let isTooClose = false;
                for (const usedHue of usedHues) {
                    const hueDiff = Math.abs(pipColors.hue - usedHue);
                    // Account for circular nature of hue (0° = 360°)
                    const circularDiff = Math.min(hueDiff, 360 - hueDiff);
                    if (circularDiff < MIN_HUE_DIFFERENCE) {
                        isTooClose = true;
                        break;
                    }
                }
                
                if (!isTooClose) {
                    break; // Found a unique hue
                }
            } while (attempts < maxAttempts);
            
            // Mark this hue as used
            usedHues.add(pipColors.hue);
            
            const face = document.querySelector(`.face-${faceNum}`);
            
            if (face) {
                // Apply unique colors to each face via CSS variables
                face.style.setProperty('--pip-color-light', pipColors.light);
                face.style.setProperty('--pip-color-mid', pipColors.mid);
                face.style.setProperty('--pip-color-dark', pipColors.dark);
                face.style.setProperty(
                    '--pip-color-darkest',
                    pipColors.darkest
                );
                face.style.setProperty(
                    '--pip-shadow-dark',
                    pipColors.shadowDark
                );
                face.style.setProperty('--pip-shadow-mid', pipColors.shadowMid);
                face.style.setProperty(
                    '--pip-shadow-extra',
                    pipColors.shadowExtra
                );
                face.style.setProperty('--pip-highlight', pipColors.highlight);
                face.style.setProperty(
                    '--pip-highlight-bright',
                    pipColors.highlightBright
                );
                face.style.setProperty(
                    '--pip-shadow-outer',
                    pipColors.shadowOuter
                );
                face.style.setProperty('--pip-border', pipColors.border);
                
                // Store for testing
                window.faceColors[faceNum] = pipColors;
            }
        }

        // Keep a stable hue reference for tests.
        window.pipColorHue = window.currentPipColors.hue;

        // ================================================================
        // DOM Element References
        // ================================================================
        const dice = document.getElementById('dice');
        const shadow = document.getElementById('shadow');
        const result = document.getElementById('result');
        const scene = document.getElementById('scene');
        const die2d = document.getElementById('die2d');
        const coin = document.getElementById('coin');
        const die2dValue = document.getElementById('die2dValue');
        const die2dLabel = document.getElementById('die2dLabel');
        const faceCountInput = document.getElementById('faceCount');
        const faceCountHint = document.getElementById('faceCountHint');

        // ================================================================
        // State Variables
        // ================================================================
        let isRolling = false;      // Prevents multiple simultaneous rolls
        let animationId = null;     // RAF handle for cancellation
        let rollEndTimeoutId = null; // End-of-roll timer (cleared on restart)
        let lastRollResult = null;  // Stores last roll result for testing

        let diceFaceCount = 6;
        let die2dAngle = 0;
        let coinAngle = 0;
        window.diceFaceCount = diceFaceCount;

        function clampFaceCount(value) {
            const n = Number(value);
            if (!Number.isFinite(n)) {
                return 6;
            }
            return Math.max(2, Math.min(20, Math.round(n)));
        }

        function getFacesParamFromSearch(search) {
            try {
                const qs = new URLSearchParams(String(search || ''));
                const raw = qs.get('faces');
                if (raw === null || raw === '') {
                    return null;
                }

                const n = Number(raw);
                if (!Number.isFinite(n)) {
                    return null;
                }

                return n;
            } catch {
                return null;
            }
        }

        function applyFacesParamFromSearch(search) {
            const faces = getFacesParamFromSearch(search);
            if (faces === null) {
                return false;
            }
            setDiceFaceCount(faces);
            return true;
        }

        // Apply initial face count from URL (?faces=<number>) without
        // calling setDiceFaceCount yet (rollHistory isn't initialized).
        // This only sets the initial value; later UI init uses diceFaceCount.
        {
            const faces = getFacesParamFromSearch(window.location.search);
            if (faces !== null) {
                diceFaceCount = clampFaceCount(faces);
                window.diceFaceCount = diceFaceCount;
            }
        }

        function updateFaceCountValidity() {
            if (!faceCountInput) {
                return;
            }

            const raw = faceCountInput.value;
            const n = Number(raw);
            const ok =
                Number.isFinite(n) &&
                Number.isInteger(n) &&
                n >= 2 &&
                n <= 20;
            faceCountInput.setAttribute('aria-invalid', String(!ok));
        }

        function regularPolygonClip(edges) {
            const n = Math.round(Number(edges));
            if (!Number.isFinite(n) || n < 3) {
                return '';
            }

            const r = 48;
            let a0 = -Math.PI / 2;
            if (n % 2 === 0) {
                a0 += Math.PI / n;
            }

            const pts = [];
            for (let i = 0; i < n; i++) {
                const a = a0 + (2 * Math.PI * i) / n;
                const x = 50 + r * Math.cos(a);
                const y = 50 + r * Math.sin(a);
                pts.push(`${x.toFixed(1)}% ${y.toFixed(1)}%`);
            }
            return `polygon(${pts.join(',')})`;
        }

        function coinFaceLabel(face) {
            return face === 1 ? 'Heads' : 'Tails';
        }

        function coinFaceChip(face) {
            return face === 1 ? 'H' : 'T';
        }

        function alignAngleToMod(angle, targetMod) {
            const a = Number(angle);
            const t = Number(targetMod);
            if (!Number.isFinite(a) || !Number.isFinite(t)) {
                return angle;
            }

            const m = ((a % 360) + 360) % 360;
            let d = t - m;
            d = ((d + 540) % 360) - 180;
            return a + d;
        }

        function makeCounts(maxFace) {
            const counts = {};
            for (let face = 1; face <= maxFace; face++) {
                counts[face] = 0;
            }
            return counts;
        }

        function setDieMode() {
            const isCube = diceFaceCount === 6;
            const isCoin = diceFaceCount === 2;

            if (dice) {
                dice.style.display = isCube ? '' : 'none';
            }
            if (die2d) {
                die2d.style.display = isCube || isCoin ? 'none' : 'flex';
                die2d.setAttribute('aria-hidden', String(isCube || isCoin));

                if (isCube || isCoin) {
                    die2d.style.removeProperty('--die2d-clip');
                    die2d.style.borderRadius = '';
                } else {
                    const clip = regularPolygonClip(diceFaceCount);
                    if (clip) {
                        die2d.style.setProperty('--die2d-clip', clip);
                        die2d.style.borderRadius = '0';
                    } else {
                        die2d.style.removeProperty('--die2d-clip');
                        die2d.style.borderRadius = '';
                    }
                }
            }

            if (coin) {
                coin.style.display = isCube || !isCoin ? 'none' : 'flex';
                coin.setAttribute('aria-hidden', String(isCube || !isCoin));
                if (isCoin) {
                    coin.style.setProperty('--coin-y', '0px');
                    coin.style.setProperty('--coin-scale', '1');
                    coin.style.setProperty('--coin-rot', `${coinAngle}deg`);
                }
            }

            if (faceCountHint) {
                faceCountHint.textContent = isCoin ? 'H/T' : '';
            }

            if (die2dLabel) {
                die2dLabel.textContent = `D${diceFaceCount}`;
            }
            if (die2dValue) {
                const v = Number.isInteger(lastRollResult) ?
                    lastRollResult :
                    diceFaceCount;
                die2dValue.textContent = String(
                    Math.max(1, Math.min(diceFaceCount, v))
                );
            }
        }

        function resetRollHistory() {
            rollHistory.rolls = [];
            rollHistory.counts = makeCounts(diceFaceCount);
            rollHistory.totalRolls = 0;
            updateHistoryUI();
        }

        function setDiceFaceCount(value) {
            const next = clampFaceCount(value);
            if (next === diceFaceCount) {
                if (faceCountInput) {
                    faceCountInput.value = String(diceFaceCount);
                    updateFaceCountValidity();
                }
                return;
            }

            stopRollImmediate();
            diceFaceCount = next;
            window.diceFaceCount = diceFaceCount;

            if (faceCountInput) {
                faceCountInput.value = String(diceFaceCount);
                updateFaceCountValidity();
            }
            if (result) {
                result.textContent = '';
                result.classList.remove('show');
            }

            setDieMode();
            resetRollHistory();
        }

        if (faceCountInput) {
            faceCountInput.value = String(diceFaceCount);
            updateFaceCountValidity();
            faceCountInput.addEventListener('input', () => {
                updateFaceCountValidity();
            });
            faceCountInput.addEventListener('change', () => {
                setDiceFaceCount(faceCountInput.value);
                updateFaceCountValidity();
            });
        }
        setDieMode();

        // ================================================================
        // Sound
        // Rolling sound is off by default and must be user-enabled.
        // ================================================================
        let soundEnabled = false;
        let soundCtx = null;
        let soundBed = null;
        let soundBedFilter = null;
        let soundBedGain = null;
        let soundMasterGain = null;
        let soundImpactBuffer = null;
        let soundImpactBufferSr = 0;
        let coinNoiseBuffer = null;
        let coinNoiseBufferSr = 0;
        let coinSoundNodes = [];
        let celebrationBuffer = null;
        let celebrationBufferSr = 0;
        let celebrationLastPlayTime = -Infinity;
        let soundModRafId = null;
        let soundStartTime = 0;
        let soundNextImpactTime = 0;
        let soundDurationSec = 0;
        let isRollingSoundPlaying = false;

        function getAudioContextCtor() {
            return window.AudioContext || window.webkitAudioContext || null;
        }

        function getOrCreateSoundContext() {
            if (soundCtx) {
                return soundCtx;
            }

            const AudioCtx = getAudioContextCtor();
            if (!AudioCtx) {
                return null;
            }

            try {
                soundCtx = new AudioCtx();
                return soundCtx;
            } catch {
                return null;
            }
        }

        function stopRollingSound() {
            if (soundModRafId) {
                cancelAnimationFrame(soundModRafId);
                soundModRafId = null;
            }

            if (!isRollingSoundPlaying) {
                return;
            }

            isRollingSoundPlaying = false;

            if (soundCtx && soundMasterGain) {
                try {
                    const t = soundCtx.currentTime;
                    soundMasterGain.gain.cancelScheduledValues(t);
                    soundMasterGain.gain.setValueAtTime(
                        soundMasterGain.gain.value,
                        t
                    );
                    soundMasterGain.gain.linearRampToValueAtTime(0, t + 0.03);
                } catch {
                    // Ignore
                }
            }

            if (soundBed) {
                try {
                    soundBed.stop();
                } catch {
                    // Ignore
                }
            }

            for (const n of coinSoundNodes) {
                if (!n) {
                    continue;
                }
                try {
                    if (typeof n.stop === 'function') {
                        n.stop();
                    }
                } catch {
                    // Ignore
                }
                try {
                    n.disconnect();
                } catch {
                    // Ignore
                }
            }

            const nodes = [soundBed, soundBedFilter, soundBedGain,
                soundMasterGain];
            for (const n of nodes) {
                if (!n) {
                    continue;
                }
                try {
                    n.disconnect();
                } catch {
                    // Ignore
                }
            }

            soundBed = null;
            soundBedFilter = null;
            soundBedGain = null;
            soundMasterGain = null;
            coinSoundNodes = [];
            soundStartTime = 0;
            soundNextImpactTime = 0;
            soundDurationSec = 0;
        }

        function getImpactBuffer(ctx) {
            if (soundImpactBuffer && soundImpactBufferSr === ctx.sampleRate) {
                return soundImpactBuffer;
            }

            const sr = ctx.sampleRate || 44100;
            const len = Math.floor(sr * 0.05);
            const buf = ctx.createBuffer(1, len, sr);
            const data = buf.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            soundImpactBuffer = buf;
            soundImpactBufferSr = sr;
            return buf;
        }

        function getCoinNoiseBuffer(ctx) {
            if (coinNoiseBuffer && coinNoiseBufferSr === ctx.sampleRate) {
                return coinNoiseBuffer;
            }

            const sr = ctx.sampleRate || 44100;
            const len = Math.floor(sr * 0.12);
            const buf = ctx.createBuffer(1, len, sr);
            const data = buf.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            coinNoiseBuffer = buf;
            coinNoiseBufferSr = sr;
            return buf;
        }

        function scheduleCoinTing(ctx, when, baseHz, amp, decay) {
            if (!soundMasterGain) {
                return;
            }

            let osc;
            try {
                osc = ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = baseHz;
            } catch {
                return;
            }

            const g = ctx.createGain();
            g.gain.value = 0;
            osc.connect(g);
            g.connect(soundMasterGain);

            try {
                g.gain.setValueAtTime(0.0001, when);
                g.gain.linearRampToValueAtTime(amp, when + 0.002);
                g.gain.exponentialRampToValueAtTime(0.0001, when + decay);
            } catch {
                // Ignore
            }

            try {
                osc.start(when);
                osc.stop(when + decay + 0.02);
            } catch {
                // Ignore
            }

            coinSoundNodes.push(osc, g);
        }

        function scheduleCoinClink(ctx, when, amp) {
            if (!soundMasterGain) {
                return;
            }

            let noise;
            try {
                noise = ctx.createBufferSource();
                noise.buffer = getCoinNoiseBuffer(ctx);
                noise.loop = false;
            } catch {
                return;
            }

            const bp = ctx.createBiquadFilter();
            bp.type = 'bandpass';
            bp.frequency.value = 4200 + Math.random() * 1200;
            bp.Q.value = 10;

            const g = ctx.createGain();
            g.gain.value = 0;

            noise.connect(bp);
            bp.connect(g);
            g.connect(soundMasterGain);

            try {
                g.gain.setValueAtTime(0.0001, when);
                g.gain.linearRampToValueAtTime(amp, when + 0.002);
                g.gain.exponentialRampToValueAtTime(0.0001, when + 0.16);
            } catch {
                // Ignore
            }

            try {
                noise.start(when);
                noise.stop(when + 0.20);
            } catch {
                // Ignore
            }

            const f1 = 2100 + Math.random() * 380;
            const f2 = 3600 + Math.random() * 620;
            scheduleCoinTing(ctx, when, f1, amp * 0.55, 0.28);
            scheduleCoinTing(ctx, when + 0.012, f2, amp * 0.42, 0.34);

            coinSoundNodes.push(noise, bp, g);
        }

        function startCoinTossSound(ctx, durationMs) {
            try {
                soundMasterGain = ctx.createGain();
                soundMasterGain.gain.value = 0.22;
                soundMasterGain.connect(ctx.destination);
                isRollingSoundPlaying = true;
            } catch {
                stopRollingSound();
                return;
            }

            const now = ctx.currentTime;
            const dur = Math.max(0.8, (durationMs || 3200) / 1000);
            const a0 = now + 0.03;

            for (let i = 0; i < 6; i++) {
                const t = a0 + i * (0.05 + Math.random() * 0.03);
                const hz = 3600 + Math.random() * 2200;
                const amp = 0.06 + Math.random() * 0.04;
                const dec = 0.06 + Math.random() * 0.05;
                scheduleCoinTing(ctx, t, hz, amp, dec);
            }

            const land = now + dur * 0.82;
            scheduleCoinClink(ctx, land, 0.20);
            scheduleCoinClink(ctx, land + 0.07, 0.12);
        }

        function getCelebrationBuffer(ctx) {
            if (celebrationBuffer && celebrationBufferSr === ctx.sampleRate) {
                return celebrationBuffer;
            }

            const sr = ctx.sampleRate || 44100;
            const dur = 2.2;
            const len = Math.floor(sr * dur);
            const buf = ctx.createBuffer(1, len, sr);
            const data = buf.getChannelData(0);

            const notes = [
                { t: 0.00, f: 523.25, a: 0.52 },
                { t: 0.12, f: 659.26, a: 0.46 },
                { t: 0.24, f: 783.99, a: 0.42 },
                { t: 0.36, f: 1046.50, a: 0.40 },
                { t: 0.54, f: 659.26, a: 0.34 },
                { t: 0.66, f: 783.99, a: 0.31 },
                { t: 0.78, f: 1046.50, a: 0.29 },
                { t: 0.96, f: 783.99, a: 0.26 },
                { t: 1.08, f: 659.26, a: 0.24 },
                { t: 1.20, f: 1046.50, a: 0.22 },
                { t: 1.36, f: 783.99, a: 0.20 },
                { t: 1.52, f: 659.26, a: 0.18 },
                { t: 1.68, f: 523.25, a: 0.16 }
            ];

            for (let i = 0; i < len; i++) {
                const t = i / sr;
                let s = 0;

                for (const n of notes) {
                    const dt = t - n.t;
                    if (dt < 0 || dt > 0.26) {
                        continue;
                    }

                    const env = Math.exp(-dt * 11);
                    const w = 2 * Math.PI * n.f * dt;
                    s += n.a * env * (Math.sin(w) + 0.18 * Math.sin(2 * w));
                }

                const tailEnv = Math.exp(-t * 1.25);
                const tail = tailEnv * (
                    0.10 * Math.sin(2 * Math.PI * 261.63 * t) +
                    0.03 * Math.sin(2 * Math.PI * 523.25 * t)
                );

                const sparkleEnv = Math.exp(-t * 2.2);
                const sparkle = (Math.random() * 2 - 1) * sparkleEnv * 0.10;
                data[i] = Math.max(
                    -1,
                    Math.min(1, (s * 0.46) + tail + sparkle)
                );
            }

            celebrationBuffer = buf;
            celebrationBufferSr = sr;
            return buf;
        }

        function playCelebrationSound() {
            if (!soundEnabled) {
                return;
            }

            const ctx = getOrCreateSoundContext();
            if (!ctx) {
                return;
            }

            try {
                const maybePromise = ctx.resume && ctx.resume();
                if (maybePromise && typeof maybePromise.catch === 'function') {
                    maybePromise.catch(() => {});
                }
            } catch {
                // Ignore
            }

            const now = ctx.currentTime || 0;
            if (now - celebrationLastPlayTime < 1.9) {
                return;
            }
            celebrationLastPlayTime = now;

            let src;
            try {
                src = ctx.createBufferSource();
                src.buffer = getCelebrationBuffer(ctx);
                src.loop = false;
            } catch {
                return;
            }

            const g = ctx.createGain();
            g.gain.value = 0;
            src.connect(g);

            const out = soundMasterGain || ctx.destination;
            try {
                g.connect(out);
            } catch {
                return;
            }

            try {
                g.gain.setValueAtTime(0.0001, now);
                g.gain.linearRampToValueAtTime(0.40, now + 0.030);
                g.gain.linearRampToValueAtTime(0.24, now + 0.12);
                g.gain.exponentialRampToValueAtTime(0.0001, now + 2.15);
            } catch {
                // Ignore
            }

            try {
                src.start(now);
                src.stop(now + 2.22);
            } catch {
                // Ignore
            }

            window.celebrationPlayCount =
                (window.celebrationPlayCount || 0) + 1;
        }

        function scheduleImpact(ctx, when, p) {
            if (!soundMasterGain) {
                return;
            }

            const speed = Math.max(0, 1 - Math.min(1, p));
            const ampBase = 0.22 * Math.pow(speed, 0.55) + 0.03;
            const ampRand = 0.75 + Math.random() * 0.5;
            const thudAmp = ampBase * 0.85 * ampRand;
            const clickAmp = ampBase * 0.55 * (0.7 + Math.random() * 0.6);

            let src;
            try {
                src = ctx.createBufferSource();
                src.buffer = getImpactBuffer(ctx);
                src.loop = false;
            } catch {
                return;
            }

            const thudFilter = ctx.createBiquadFilter();
            thudFilter.type = 'lowpass';
            thudFilter.frequency.value = 260 + Math.random() * 140;
            thudFilter.Q.value = 0.7;

            const clickFilter = ctx.createBiquadFilter();
            clickFilter.type = 'bandpass';
            clickFilter.frequency.value = 2200 + Math.random() * 2400;
            clickFilter.Q.value = 7 + Math.random() * 5;

            const thudGain = ctx.createGain();
            const clickGain = ctx.createGain();
            thudGain.gain.value = 0;
            clickGain.gain.value = 0;

            src.connect(thudFilter);
            src.connect(clickFilter);
            thudFilter.connect(thudGain);
            clickFilter.connect(clickGain);
            thudGain.connect(soundMasterGain);
            clickGain.connect(soundMasterGain);

            const attack = 0.002;
            const thudDecay = 0.07;
            const clickDecay = 0.03;
            const thudT = when + thudDecay;
            const clickT = when + clickDecay;

            thudGain.gain.setValueAtTime(0, when);
            thudGain.gain.linearRampToValueAtTime(thudAmp, when + attack);
            thudGain.gain.exponentialRampToValueAtTime(0.0001, thudT);

            clickGain.gain.setValueAtTime(0, when);
            clickGain.gain.linearRampToValueAtTime(clickAmp, when + attack);
            clickGain.gain.exponentialRampToValueAtTime(0.0001, clickT);

            try {
                src.start(when);
                src.stop(when + 0.12);
            } catch {
                // Ignore
            }
        }

        function startRollingSound(durationMs) {
            if (!soundEnabled) {
                return;
            }

            if (isRollingSoundPlaying) {
                return;
            }

            const ctx = getOrCreateSoundContext();
            if (!ctx) {
                return;
            }

            try {
                const maybePromise = ctx.resume && ctx.resume();
                if (maybePromise && typeof maybePromise.catch === 'function') {
                    maybePromise.catch(() => {});
                }
            } catch {
                // Ignore
            }

            if (diceFaceCount === 2) {
                startCoinTossSound(ctx, durationMs);
                return;
            }

            try {
                soundMasterGain = ctx.createGain();
                soundMasterGain.gain.value = 0.18;
                soundMasterGain.connect(ctx.destination);

                // Very soft background bed (subtle friction), but the main
                // character is the bouncing impacts.
                const sr = ctx.sampleRate || 44100;
                const len = Math.floor(sr * 0.4);
                const buf = ctx.createBuffer(1, len, sr);
                const data = buf.getChannelData(0);
                let brown = 0;
                for (let i = 0; i < data.length; i++) {
                    const white = Math.random() * 2 - 1;
                    brown = (brown + 0.01 * white) / 1.01;
                    data[i] = Math.max(-1, Math.min(1, brown * 3));
                }

                soundBed = ctx.createBufferSource();
                soundBed.buffer = buf;
                soundBed.loop = true;
                soundBedFilter = ctx.createBiquadFilter();
                soundBedFilter.type = 'lowpass';
                soundBedFilter.frequency.value = 230;
                soundBedFilter.Q.value = 0.6;
                soundBedGain = ctx.createGain();
                soundBedGain.gain.value = 0.015;
                soundBed.connect(soundBedFilter);
                soundBedFilter.connect(soundBedGain);
                soundBedGain.connect(soundMasterGain);
                soundBed.start();

                soundStartTime = ctx.currentTime;
                soundDurationSec = Math.max(0.8, (durationMs || 3500) / 1000);
                soundNextImpactTime = soundStartTime;
                isRollingSoundPlaying = true;
            } catch {
                stopRollingSound();
                return;
            }

            function tick() {
                if (!isRollingSoundPlaying || !soundCtx) {
                    return;
                }

                const now = soundCtx.currentTime;
                const age = Math.max(0, now - soundStartTime);
                const p = Math.min(age / Math.max(0.001, soundDurationSec), 1);

                // Schedule impacts slightly ahead for stable timing.
                const ahead = 0.12;
                while (soundNextImpactTime < now + ahead && p < 1) {
                    scheduleImpact(soundCtx, soundNextImpactTime, p);
                    const minI = 0.03;
                    const maxI = 0.22;
                    const base = minI + (maxI - minI) * Math.pow(p, 0.85);
                    const jitter = 0.7 + Math.random() * 0.6;
                    soundNextImpactTime += base * jitter;

                    if (p < 0.35 && Math.random() < 0.18) {
                        scheduleImpact(soundCtx, soundNextImpactTime + 0.012,
                            Math.min(1, p + 0.08));
                    }
                }

                soundModRafId = requestAnimationFrame(tick);
            }

            tick();
        }

        // ================================================================
        // Face Rotation Mappings
        // Defines the X/Y rotation needed to show each face on top
        // ================================================================
        const faceRotations = {
            1: { x: 0, y: 0 },       // Front face
            2: { x: 0, y: 180 },     // Back face
            3: { x: 0, y: -90 },     // Right face
            4: { x: 0, y: 90 },      // Left face
            5: { x: -90, y: 0 },     // Top face
            6: { x: 90, y: 0 }       // Bottom face
        };

        // ================================================================
        // Physics State
        // Current rotation angles of the dice
        // ================================================================
        let rotationX = -25;  // Initial X rotation (slight tilt)
        let rotationY = 25;   // Initial Y rotation (slight tilt)
        let rotationZ = 0;    // Z rotation (twist) to ensure full 3D motion

        // ================================================================
        // Easing Functions
        // These create natural motion curves for animation
        // ================================================================

        /**
         * Natural dice roll easing - pure deceleration
         * Simulates a thrown dice: starts at max speed, continuously slows
         * Uses quartic ease-out for smooth, realistic friction effect
         * @param {number} t - progress from 0 to 1
         * @returns {number} eased value from 0 to 1
         */
        function easeNaturalRoll(t) {
            // Quartic ease-out: fast start, gradual deceleration
            // At t=0.25: ~68% complete (fast initial motion)
            // At t=0.50: ~94% complete (slowing down)
            // At t=0.75: ~99.6% complete (nearly stopped)
            // At t=1.00: 100% complete (rest)
            return 1 - Math.pow(1 - t, 4);
        }

        /**
         * Legacy gravity easing (kept for unit tests)
         * @param {number} t - progress from 0 to 1
         * @returns {number} eased value from 0 to 1
         */
        function easeOutGravity(t) {
            return 1 - Math.pow(1 - t, 7);
        }

        // ================================================================
        // Confetti Burst
        // Shown when the dice finishes on the max value
        // ================================================================

        function getConfettiPalette() {
            const colors = [];
            const faces = document.querySelectorAll('.face');

            for (const face of faces) {
                const mid = getComputedStyle(face)
                    .getPropertyValue('--pip-color-mid')
                    .trim();
                if (mid) colors.push(mid);
            }

            return colors;
        }

        let confettiRafId = null;
        let confettiLastMs = 0;
        let confettiPieces = [];

        function setConfettiStyle(piece) {
            piece.el.style.transform =
                `translate(calc(-50% + ${piece.x.toFixed(1)}px), ` +
                `calc(-50% + ${piece.y.toFixed(1)}px)) ` +
                `rotate(${piece.rot.toFixed(1)}deg)`;
        }

        function stepConfetti(nowMs) {
            if (confettiLastMs === 0) {
                confettiLastMs = nowMs;
            }

            const dtMs = Math.min(50, Math.max(0, nowMs - confettiLastMs));
            confettiLastMs = nowMs;
            const dt = dtMs / 1000;

            for (let i = confettiPieces.length - 1; i >= 0; i--) {
                const p = confettiPieces[i];
                p.ageMs += dtMs;

                p.vy += p.g * dt;
                p.vx *= 1 / (1 + p.drag * dt);
                p.vy *= 1 / (1 + p.drag * dt);

                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.rot += p.vr * dt;

                const t = Math.min(p.ageMs / p.lifeMs, 1);
                const fadeStart = 0.65;
                let alpha = 1;
                if (t >= fadeStart) {
                    alpha = Math.max(0, 1 - (t - fadeStart) / (1 - fadeStart));
                }

                p.el.style.opacity = alpha.toFixed(3);
                setConfettiStyle(p);

                if (t >= 1) {
                    p.el.remove();
                    confettiPieces.splice(i, 1);
                }
            }

            if (confettiPieces.length === 0) {
                confettiRafId = null;
                confettiLastMs = 0;
                return;
            }

            confettiRafId = requestAnimationFrame(stepConfetti);
        }

        function triggerConfettiBurst() {
            const layer = document.getElementById('confettiLayer');
            if (!layer) return;

            const palette = getConfettiPalette();
            if (palette.length === 0) return;

            playCelebrationSound();

            const count = 140;
            const gBase = 1550;
            for (let i = 0; i < count; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti';

                const color =
                    palette[Math.floor(Math.random() * palette.length)];
                piece.style.setProperty('--confetti-color', color);
                layer.appendChild(piece);

                const streamer = Math.random() < 0.22;
                const w = streamer ?
                    4 + Math.random() * 4 :
                    5 + Math.random() * 7;
                const h = streamer ?
                    16 + Math.random() * 16 :
                    8 + Math.random() * 12;
                piece.style.width = `${w.toFixed(1)}px`;
                piece.style.height = `${h.toFixed(1)}px`;

                const ang = -Math.PI / 2 + (Math.random() - 0.5) * 1.7;
                const spd = 520 + Math.random() * 720;
                const vx = Math.cos(ang) * spd;
                const vy = Math.sin(ang) * spd;
                const rot = (Math.random() - 0.5) * 360;
                const vr = (Math.random() - 0.5) * 900;
                const drag = 0.8 + Math.random() * 1.0;
                const g = gBase + Math.random() * 550;
                const lifeMs = 2400 + Math.random() * 900;

                confettiPieces.push({
                    el: piece,
                    x: 0,
                    y: 0,
                    vx,
                    vy,
                    rot,
                    vr,
                    drag,
                    g,
                    ageMs: 0,
                    lifeMs
                });

                setConfettiStyle(confettiPieces[confettiPieces.length - 1]);
            }

            if (confettiRafId) {
                cancelAnimationFrame(confettiRafId);
                confettiRafId = null;
            }
            confettiLastMs = 0;
            confettiRafId = requestAnimationFrame(stepConfetti);
        }

        function stopRollImmediate() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (rollEndTimeoutId) {
                clearTimeout(rollEndTimeoutId);
                rollEndTimeoutId = null;
            }

            stopRollingSound();

            isRolling = false;
            if (dice) {
                dice.classList.remove('rolling');
            }
            if (shadow) {
                shadow.classList.remove('rolling');
            }
            if (die2d) {
                die2d.classList.remove('rolling');
            }
        }

        // ================================================================
        // Main Roll Function
        // Initiates the dice roll animation
        // ================================================================
        function rollDice(forceResult) {
            // Allow clicking during roll - cancel current animation
            if (isRolling && animationId) {
                cancelAnimationFrame(animationId);
            }

            // If a previous roll finished and scheduled an end timer,
            // restarting quickly can let that stale timer flip isRolling
            // during the new roll.
            if (rollEndTimeoutId) {
                clearTimeout(rollEndTimeoutId);
                rollEndTimeoutId = null;
            }

            // Ensure any prior roll sound is stopped before restarting.
            stopRollingSound();

            isRolling = true;

            // Add rolling state classes for CSS effects
            if (shadow) {
                shadow.classList.add('rolling');
            }
            if (result) {
                result.classList.remove('show');
            }

            // Determine final face (1..diceFaceCount), can be forced
            const forced = Number(forceResult);
            const hasForced = Number.isInteger(forced);
            const finalFace = hasForced ?
                Math.max(1, Math.min(diceFaceCount, forced)) :
                (Math.floor(Math.random() * diceFaceCount) + 1);
            lastRollResult = finalFace;

            const isCube = diceFaceCount === 6;
            if (dice) {
                dice.classList.toggle('rolling', isCube);
            }
            if (die2d) {
                die2d.classList.toggle('rolling', !isCube);
            }
            if (coin) {
                coin.classList.toggle(
                    'rolling',
                    !isCube && diceFaceCount === 2
                );
            }

            if (!isCube) {
                setDieMode();
            }

            // Natural roll duration - not too long, not too short
            // 3-4 seconds feels like a real dice roll
            const duration = 3000 + Math.random() * 1000;

            // Store duration for testing
            window.lastRollDuration = duration;
            const startTime = performance.now();

            // Start sound only if user enabled it.
            startRollingSound(duration);

            if (!isCube && diceFaceCount === 2) {
                const startA = coinAngle;
                const flips = (Math.floor(Math.random() * 3) + 5) * 360;
                const dir = Math.random() > 0.5 ? 1 : -1;
                const target = finalFace === 2 ? 180 : 0;
                const baseA = startA + flips * dir;
                const endA = alignAngleToMod(baseA, target);
                const heightPx = 76;
                const scaleBoost = 0.06;

                window.lastRollRotationPlan = {
                    startZ: startA,
                    endZ: endA,
                    deltaZ: endA - startA,
                    face: finalFace,
                    mode: 'coin'
                };

                function animateCoin(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = easeNaturalRoll(progress);
                    coinAngle = startA + (endA - startA) * eased;

                    const lift = 4 * heightPx * progress * (1 - progress);
                    const y = -lift;
                    const s = 1 + (lift / heightPx) * scaleBoost;

                    if (coin) {
                        coin.style.setProperty(
                            '--coin-rot',
                            `${coinAngle}deg`
                        );
                        coin.style.setProperty('--coin-y', `${y}px`);
                        coin.style.setProperty('--coin-scale', String(s));
                    }

                    if (
                        progress >= 0.7 &&
                        result &&
                        !result.classList.contains('show')
                    ) {
                        result.textContent = coinFaceLabel(finalFace);
                        result.classList.add('show');
                        recordRoll(finalFace);
                        if (finalFace === diceFaceCount) {
                            triggerConfettiBurst();
                        }
                    }

                    if (progress < 1) {
                        animationId = requestAnimationFrame(animateCoin);
                    } else {
                        if (shadow) {
                            shadow.classList.remove('rolling');
                        }
                        if (coin) {
                            coin.classList.remove('rolling');
                        }

                        stopRollingSound();
                        hasRolledOnce = true;

                        rollEndTimeoutId = setTimeout(() => {
                            isRolling = false;
                            rollEndTimeoutId = null;
                        }, 100);
                    }
                }

                if (coin) {
                    coin.classList.add('rolling');
                }
                animationId = requestAnimationFrame(animateCoin);
                return finalFace;
            }

            if (!isCube) {
                const startA = die2dAngle;
                const spins = (Math.floor(Math.random() * 3) + 4) * 360;
                const dir = Math.random() > 0.5 ? 1 : -1;
                const endA = startA + spins * dir;

                window.lastRollRotationPlan = {
                    startZ: startA,
                    endZ: endA,
                    deltaZ: endA - startA,
                    face: finalFace,
                    mode: 'flat'
                };

                function animateFlat(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = easeNaturalRoll(progress);

                    die2dAngle = startA + (endA - startA) * eased;
                    if (die2d) {
                        die2d.style.setProperty(
                            '--die2d-rot',
                            `${die2dAngle}deg`
                        );
                    }

                    if (progress < 0.7 && die2dValue) {
                        die2dValue.textContent = String(
                            Math.floor(Math.random() * diceFaceCount) + 1
                        );
                    }

                    if (
                        progress >= 0.7 &&
                        result &&
                        !result.classList.contains('show')
                    ) {
                        result.textContent = finalFace;
                        result.classList.add('show');
                        if (die2dValue) {
                            die2dValue.textContent = String(finalFace);
                        }
                        recordRoll(finalFace);
                        if (finalFace === diceFaceCount) {
                            triggerConfettiBurst();
                        }
                    }

                    if (progress < 1) {
                        animationId = requestAnimationFrame(animateFlat);
                    } else {
                        if (shadow) {
                            shadow.classList.remove('rolling');
                        }
                        if (die2d) {
                            die2d.classList.remove('rolling');
                        }

                        stopRollingSound();
                        hasRolledOnce = true;

                        rollEndTimeoutId = setTimeout(() => {
                            isRolling = false;
                            rollEndTimeoutId = null;
                        }, 100);
                    }
                }

                animationId = requestAnimationFrame(animateFlat);
                return finalFace;
            }

            const targetRotation = faceRotations[finalFace];

            // Calculate total rotation (multiple full spins + final)
            // Moderate rotations for natural-looking tumble
            const fullRotationsX = (Math.floor(Math.random() * 2) + 2) * 360;
            const fullRotationsY = (Math.floor(Math.random() * 2) + 2) * 360;
            const fullRotationsZ = (Math.floor(Math.random() * 1) + 1) * 360;

            // Randomize rotation direction for variety
            const dirX = Math.random() > 0.5 ? 1 : -1;
            const dirY = Math.random() > 0.5 ? 1 : -1;
            const dirZ = Math.random() > 0.5 ? 1 : -1;

            // Store start and end positions
            const startX = rotationX;
            const startY = rotationY;
            const startZ = rotationZ;
            let endX = targetRotation.x + fullRotationsX * dirX;
            let endY = targetRotation.y + fullRotationsY * dirY;
            // Z adds a subtle twist for realism (less aggressive than before)
            let endZ = startZ + fullRotationsZ * dirZ;

            // Guard against rare cases where start and end align.
            // Numeric continuity matters.
            const MIN_AXIS_DELTA_DEG = 90;
            if (Math.abs(endX - startX) < MIN_AXIS_DELTA_DEG) {
                endX += 360 * dirX;
            }
            if (Math.abs(endY - startY) < MIN_AXIS_DELTA_DEG) {
                endY += 360 * dirY;
            }
            if (Math.abs(endZ - startZ) < MIN_AXIS_DELTA_DEG) {
                endZ += 360 * dirZ;
            }

            // Expose plan for unit tests
            window.lastRollRotationPlan = {
                startX,
                startY,
                startZ,
                targetX: targetRotation.x,
                targetY: targetRotation.y,
                endX,
                endY,
                endZ,
                deltaX: endX - startX,
                deltaY: endY - startY,
                deltaZ: endZ - startZ,
                face: finalFace
            };

            /**
             * Animation loop - called each frame via RAF
             * Calculates current rotation based on elapsed time
             */
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Apply ease-out easing for realistic roll
                const eased = easeNaturalRoll(progress);

                // Calculate current rotation - smooth interpolation, no wobble
                rotationX = startX + (endX - startX) * eased;
                rotationY = startY + (endY - startY) * eased;
                rotationZ = startZ + (endZ - startZ) * eased;

                // Apply transform to dice element
                dice.style.transform =
                    // rotateZ is applied last (leftmost) so face mapping
                    // (X/Y) stays correct.
                    `rotateZ(${rotationZ}deg) ` +
                    `rotateX(${rotationX}deg) ` +
                    `rotateY(${rotationY}deg)`;

                // Show result early when dice is slowing down (70% progress)
                if (progress >= 0.7 && !result.classList.contains('show')) {
                    result.textContent = finalFace;
                    result.classList.add('show');
                    recordRoll(finalFace);

                    if (finalFace === diceFaceCount) {
                        triggerConfettiBurst();
                    }
                }

                if (progress < 1) {
                    // Continue animation
                    animationId = requestAnimationFrame(animate);
                } else {
                    // Animation complete
                    // Note: rotationX/Y are already at correct final position
                    // from the last animation frame (endX/endY with eased=1)
                    // Do NOT reset to targetRotation - that causes numeric jump
                    // e.g., 720deg -> 0deg triggers CSS transition flip
                    
                    // Remove rolling state classes
                    dice.classList.remove('rolling');
                    shadow.classList.remove('rolling');

                    // Stop rolling sound at roll completion.
                    stopRollingSound();
                    
                    // Mark that a roll has occurred - disables idle animation
                    hasRolledOnce = true;
                    
                    // Brief pause before allowing new rolls
                    rollEndTimeoutId = setTimeout(() => {
                        isRolling = false;
                        rollEndTimeoutId = null;
                    }, 100);

                    // Result already displayed at 70% progress
                }
            }

            // Start the animation loop
            animationId = requestAnimationFrame(animate);

            return finalFace;
        }

        // ================================================================
        // Event Listeners
        // ================================================================

        // Click to roll
        scene.addEventListener('click', () => rollDice());

        // Keyboard support: Space or Enter to roll
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'Enter') {
                e.preventDefault();
                rollDice();
            }
        });

        // ================================================================
        // Idle Animation
        // Subtle floating motion when dice is not rolling
        // Completely disabled after a roll - only active on page load
        // ================================================================
        let idleAngle = 0;
        let hasRolledOnce = false;  // Track if user has rolled

        // ================================================================
        // Roll History Tracking
        // Stores session roll data for statistics display
        // ================================================================
        const rollHistory = {
            rolls: [],           // Array of roll results (most recent last)
            maxHistory: 20,      // Keep last N rolls for display
            counts: makeCounts(diceFaceCount),
            totalRolls: 0        // Total rolls this session
        };

        // Expose for testing
        window.rollHistory = rollHistory;

        /**
         * Record a roll result to history
         * @param {number} result - The dice face value (1..diceFaceCount)
         */
        function recordRoll(result) {
            const face = Number(result);
            if (!Number.isInteger(face) || face < 1 || face > diceFaceCount) {
                return;
            }
            
            rollHistory.rolls.push(face);
            // Keep only last N rolls
            if (rollHistory.rolls.length > rollHistory.maxHistory) {
                rollHistory.rolls.shift();
            }
            if (rollHistory.counts[face] === undefined) {
                rollHistory.counts[face] = 0;
            }
            rollHistory.counts[face]++;
            rollHistory.totalRolls++;
            
            // Update UI
            updateHistoryUI();
        }

        /**
         * Get percentage occurrence of each face
         * @returns {Object} Percentages keyed by face value
         */
        function getRollPercentages() {
            const percentages = {};
            for (let face = 1; face <= diceFaceCount; face++) {
                if (rollHistory.totalRolls === 0) {
                    percentages[face] = 0;
                } else {
                    percentages[face] = Math.round(
                        (rollHistory.counts[face] / rollHistory.totalRolls)
                        * 100
                    );
                }
            }
            return percentages;
        }

        // Expose for testing
        window.recordRoll = recordRoll;
        window.getRollPercentages = getRollPercentages;

        function idleAnimation() {
            // Only run idle animation if no roll has occurred yet
            // Once user rolls, dice stays still after stopping
            if (!isRolling && !hasRolledOnce) {
                const el = diceFaceCount === 6 ? dice :
                    (diceFaceCount === 2 ? coin : die2d);
                if (!el) {
                    requestAnimationFrame(idleAnimation);
                    return;
                }

                // Slow oscillation for gentle float effect
                idleAngle += 0.015;
                const wobbleX = Math.sin(idleAngle) * 2;
                const wobbleY = Math.cos(idleAngle * 0.7) * 2;
                const wobbleZ = Math.sin(idleAngle * 0.9) * 1.2;
                if (diceFaceCount === 6) {
                    dice.style.transform =
                        `rotateZ(${rotationZ + wobbleZ}deg) ` +
                        `rotateX(${rotationX + wobbleX}deg) ` +
                        `rotateY(${rotationY + wobbleY}deg)`;
                } else if (diceFaceCount === 2) {
                    coinAngle += wobbleZ * 0.05;
                    el.style.setProperty(
                        '--coin-rot',
                        `${coinAngle}deg`
                    );
                } else {
                    die2dAngle += wobbleZ * 0.05;
                    el.style.setProperty(
                        '--die2d-rot',
                        `${die2dAngle}deg`
                    );
                }
            }
            requestAnimationFrame(idleAnimation);
        }

        // Start idle animation
        idleAnimation();

        // ================================================================
        // History Tab UI
        // Shows roll history, count, and statistics
        // ================================================================
        const historyTab = document.createElement('div');
        historyTab.className = 'history-tab';
        historyTab.id = 'historyTab';
        historyTab.innerHTML = `
            <div class="history-tab-header" id="historyHeader">
                <span class="history-title">Details</span>
                <button
                    class="history-toggle-btn"
                    id="historyToggleBtn"
                    aria-label="Toggle details"
                >▸</button>
            </div>
            <div class="history-content" id="historyContent">
                <div class="history-section">
                    <div class="history-row">
                        <div class="history-row-title">Die</div>
                        <div id="detailsDieControls"></div>
                    </div>
                </div>
                <div class="history-section">
                    <div class="history-row">
                        <div class="history-row-title">Sound</div>
                        <label class="history-sound-toggle">
                            <input
                                type="checkbox"
                                id="historySoundEnabled"
                            >
                            <span>Rolling sound</span>
                        </label>
                    </div>
                </div>
                <div class="history-section">
                    <div class="history-section-title">Last 20 Rolls</div>
                    <div class="history-rolls" id="historyRolls">
                        <div class="history-empty">No rolls yet</div>
                    </div>
                </div>
                <div class="history-section">
                    <div class="history-section-title">Session Stats</div>
                    <div class="history-stat">
                        <span>Total Rolls:</span>
                        <span
                            class="history-stat-value"
                            id="historyTotalRolls"
                        >0</span>
                    </div>
                </div>
                <div class="history-section">
                    <div class="history-section-title">Distribution</div>
                    <div id="historyDistribution"></div>
                </div>
            </div>
        `;
        document.body.appendChild(historyTab);

        // Move face-count control into Details tab.
        const faceCountControl = document.getElementById('faceCountControl');
        const detailsDieControls =
            document.getElementById('detailsDieControls');
        if (faceCountControl && detailsDieControls) {
            detailsDieControls.appendChild(faceCountControl);
        }

        // History tab toggle functionality
        const historyHeader = document.getElementById('historyHeader');
        const historyToggleBtn = document.getElementById('historyToggleBtn');

        if (historyHeader && historyToggleBtn) {
            historyHeader.addEventListener('click', () => {
                const isExpanded = historyTab.classList.contains('expanded');
                historyTab.classList.toggle('expanded', !isExpanded);
                historyToggleBtn.textContent = isExpanded ? '▸' : '▾';
            });
        }

        const historySoundEnabled =
            document.getElementById('historySoundEnabled');

        if (historySoundEnabled) {
            historySoundEnabled.checked = soundEnabled;
            historySoundEnabled.addEventListener('change', () => {
                soundEnabled = Boolean(historySoundEnabled.checked);
                if (!soundEnabled) {
                    stopRollingSound();
                    return;
                }

                if (isRolling) {
                    startRollingSound();
                }
            });
        }

        /**
         * Update the History tab UI with current data
         */
        function updateHistoryUI() {
            // Update last rolls display
            const rollsContainer = document.getElementById('historyRolls');
            const totalEl = document.getElementById('historyTotalRolls');
            const distContainer =
                document.getElementById('historyDistribution');

            if (!rollsContainer || !totalEl || !distContainer) {
                return;
            }

            if (rollHistory.rolls.length === 0) {
                rollsContainer.innerHTML = (
                    '<div class="history-empty">'
                    + 'No rolls yet'
                    + '</div>'
                );
            } else {
                const isCoin = diceFaceCount === 2;
                rollsContainer.innerHTML = rollHistory.rolls
                    .map(r => {
                        const v = isCoin ? coinFaceChip(r) : String(r);
                        return `<div class="history-roll-item">${v}</div>`;
                    })
                    .join('');
            }

            // Update total rolls
            totalEl.textContent = rollHistory.totalRolls;

            function getDistClass(pct) {
                if (rollHistory.totalRolls === 0) {
                    return '';
                }

                const expected = 100 / Math.max(1, diceFaceCount);
                const delta = Math.abs(Number(pct) - expected);
                const ratio = expected > 0 ? delta / expected : 0;
                if (ratio <= 0.25) {
                    return 'dist-good';
                }
                if (ratio <= 0.60) {
                    return 'dist-ok';
                }
                return 'dist-bad';
            }

            // Update distribution bars
            const percentages = getRollPercentages();
            let distHtml = '';
            for (let face = 1; face <= diceFaceCount; face++) {
                const pct = percentages[face];
                const label = diceFaceCount === 2 ? coinFaceChip(face) : face;
                const cls = getDistClass(pct);
                distHtml += `
                    <div class="history-bar-container">
                        <span class="history-bar-label">${label}</span>
                        <div class="history-bar">
                            <div
                                class="history-bar-fill ${cls}"
                                style="width: ${pct}%"
                            ></div>
                        </div>
                        <span class="history-bar-percent">${pct}%</span>
                    </div>
                `;
            }
            distContainer.innerHTML = distHtml;
        }

        // Initialize history UI
        updateHistoryUI();

        // ================================================================
        // Unit Test Suite
        // Enabled by adding ?tests=1 to the URL
        // Shows a test tab in bottom-right with Run button
        // ================================================================
        const testsEnabled = (() => {
            try {
                const qs = new URLSearchParams(window.location.search);
                return qs.get('tests') === '1';
            } catch {
                return false;
            }
        })();

        if (testsEnabled) {
            // ============================================================
            // Test Framework
            // Simple test runner with assert helpers
            // ============================================================
            const tests = [];       // Array of registered test cases
            let testsPassed = 0;    // Counter for passed tests
            let testsFailed = 0;    // Counter for failed tests
            let testsRunning = false; // Prevents concurrent test runs

            // Keep the suite deterministic regardless of URL (?faces=...).
            // Many tests assume the default cube (D6) mode.
            if (diceFaceCount !== 6) {
                setDiceFaceCount(6);
            }

            /**
             * Register a test case for later execution
             * @param {string} name - Descriptive name shown in results
             * @param {Function} fn - Test function, throws on failure
             */
            function test(name, fn) {
                tests.push({ name, fn });
            }

            /**
             * Assert a condition is true, throw if false
             * @param {boolean} condition - Condition to verify
             * @param {string} message - Error message on failure
             */
            function assert(condition, message = 'Assertion failed') {
                if (!condition) {
                    throw new Error(message);
                }
            }

            /**
             * Assert strict equality between two values
             * @param {*} actual - Value received
             * @param {*} expected - Value expected
             */
            function eq(actual, expected) {
                if (actual !== expected) {
                    throw new Error(
                        `Expected ${expected}, got ${actual}`
                    );
                }
            }

            function mod360(n) {
                const r = n % 360;
                return r < 0 ? r + 360 : r;
            }

            function stopRollingForTests() {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                if (typeof rollEndTimeoutId !== 'undefined') {
                    if (rollEndTimeoutId) {
                        clearTimeout(rollEndTimeoutId);
                        rollEndTimeoutId = null;
                    }
                }
                isRolling = false;
                if (dice) {
                    dice.classList.remove('rolling');
                }
                if (shadow) {
                    shadow.classList.remove('rolling');
                }
                if (die2d) {
                    die2d.classList.remove('rolling');
                }
                if (coin) {
                    coin.classList.remove('rolling');
                }

                stopRollingSound();
            }

            function withRafQueue(fn) {
                const savedRaf = window.requestAnimationFrame;
                const savedCancel = window.cancelAnimationFrame;
                let nextId = 1;
                const queue = new Map();

                window.requestAnimationFrame = (cb) => {
                    const id = nextId++;
                    queue.set(id, cb);
                    return id;
                };

                window.cancelAnimationFrame = (id) => {
                    queue.delete(id);
                };

                function flushOne(time) {
                    const iter = queue.entries().next();
                    if (iter.done) {
                        return false;
                    }
                    const id = iter.value[0];
                    const cb = iter.value[1];
                    queue.delete(id);
                    cb(time);
                    return true;
                }

                function flushNamed(targetName, time) {
                    for (const [id, cb] of queue.entries()) {
                        if (cb && cb.name === targetName) {
                            queue.delete(id);
                            cb(time);
                            return true;
                        }
                    }
                    return false;
                }

                try {
                    fn({ flushOne, flushNamed, queue });
                } finally {
                    window.requestAnimationFrame = savedRaf;
                    window.cancelAnimationFrame = savedCancel;
                }
            }

            function withMockAudioContext(fn) {
                const savedAudio = window.AudioContext;
                const savedWebkit = window.webkitAudioContext;
                const state = {
                    constructed: 0,
                    starts: 0,
                    stops: 0,
                    oscillators: 0
                };

                function makeMockParam(value) {
                    return {
                        value,
                        setValueAtTime(v) {
                            this.value = v;
                        },
                        linearRampToValueAtTime(v) {
                            this.value = v;
                        },
                        exponentialRampToValueAtTime(v) {
                            this.value = v;
                        },
                        setTargetAtTime(v) {
                            this.value = v;
                        },
                        cancelScheduledValues() {}
                    };
                }

                class MockNode {
                    connect() {}
                    disconnect() {}
                }

                class MockBufferSource extends MockNode {
                    constructor() {
                        super();
                        this.buffer = null;
                        this.loop = false;
                    }
                    start() {
                        state.starts++;
                    }
                    stop() {
                        state.stops++;
                    }
                }

                class MockGain extends MockNode {
                    constructor() {
                        super();
                        this.gain = makeMockParam(0);
                    }
                }

                class MockFilter extends MockNode {
                    constructor() {
                        super();
                        this.type = 'lowpass';
                        this.frequency = makeMockParam(0);
                        this.Q = makeMockParam(0);
                    }
                }

                class MockOscillator extends MockNode {
                    constructor() {
                        super();
                        this.type = 'sine';
                        this.frequency = makeMockParam(440);
                    }
                    start() {
                        state.starts++;
                    }
                    stop() {
                        state.stops++;
                    }
                }

                class MockAudioContext {
                    constructor() {
                        state.constructed++;
                        this.destination = {};
                        this.currentTime = 1;
                        this.state = 'running';
                        this.sampleRate = 44100;
                    }
                    createBuffer(channels, length, sampleRate) {
                        return {
                            numberOfChannels: channels,
                            length,
                            sampleRate,
                            getChannelData: () => new Float32Array(length)
                        };
                    }
                    createBufferSource() {
                        return new MockBufferSource();
                    }
                    createGain() {
                        return new MockGain();
                    }
                    createBiquadFilter() {
                        return new MockFilter();
                    }
                    createOscillator() {
                        state.oscillators++;
                        return new MockOscillator();
                    }
                    resume() {
                        this.state = 'running';
                        return Promise.resolve();
                    }
                }

                window.AudioContext = MockAudioContext;
                window.webkitAudioContext = undefined;

                try {
                    fn(state);
                } finally {
                    if (savedAudio === undefined) {
                        delete window.AudioContext;
                    } else {
                        window.AudioContext = savedAudio;
                    }

                    if (savedWebkit === undefined) {
                        delete window.webkitAudioContext;
                    } else {
                        window.webkitAudioContext = savedWebkit;
                    }
                }
            }

            // ============================================================
            // Unit Tests Tab UI
            // Bottom-right tab with a single Run Tests button.
            // Expands automatically when tests are executed.
            // ============================================================
            const testTab = document.createElement('div');
            testTab.className = 'test-tab';
            testTab.innerHTML = `
                <div class="test-tab-header">
                    <button
                        class="test-run-btn"
                        id="runTestsBtn"
                    >Run Tests</button>
                    <button
                        class="test-toggle-btn"
                        id="toggleTestsBtn"
                        aria-label="Toggle tests"
                    >▸</button>
                </div>
                <div class="test-results" id="testResults"></div>
                <div class="test-summary" id="testSummary"></div>
            `;
            document.body.appendChild(testTab);

            const runBtn = document.getElementById('runTestsBtn');
            const toggleBtn = document.getElementById('toggleTestsBtn');
            const resultsDiv = document.getElementById('testResults');
            const summaryDiv = document.getElementById('testSummary');

            // Capture initial UI state for Interaction tests
            // (even after expansion during a run).
            testTab.dataset.initialExpanded = String(
                testTab.classList.contains('expanded')
            );
            if (runBtn) {
                runBtn.dataset.initialText =
                    (runBtn.textContent || '').trim();
            }
            if (resultsDiv) {
                resultsDiv.dataset.initialDisplay =
                    getComputedStyle(resultsDiv).display;
            }
            if (summaryDiv) {
                summaryDiv.dataset.initialDisplay =
                    getComputedStyle(summaryDiv).display;
            }


            /**
             * Execute all registered tests and display results
             * Runs in UI (when enabled) and prints a console summary.
             */
            async function runTests() {
                if (testsRunning) return null;
                testsRunning = true;
                try {
                    // Reset counters
                    testsPassed = 0;
                    testsFailed = 0;

                    const renderToDom = !!(resultsDiv && summaryDiv);

                    if (renderToDom) {
                        // Expand panel and clear previous output
                        testTab.classList.add('expanded');
                        if (toggleBtn) toggleBtn.textContent = '▾';
                        resultsDiv.innerHTML = '';
                        summaryDiv.innerHTML = '';
                        summaryDiv.className = 'test-summary';
                    }

                    // Track coverage by category
                    const coverage = {
                        DOM: { passed: 0, total: 0 },
                        Easing: { passed: 0, total: 0 },
                        State: { passed: 0, total: 0 },
                        CSS: { passed: 0, total: 0 },
                        Functions: { passed: 0, total: 0 },
                        Centering: { passed: 0, total: 0 },
                        Result: { passed: 0, total: 0 },
                        Interaction: { passed: 0, total: 0 },
                        History: { passed: 0, total: 0 },
                        Sound: { passed: 0, total: 0 },
                        Physics: { passed: 0, total: 0 },
                        Stability: { passed: 0, total: 0 },
                        'Random Color': { passed: 0, total: 0 }
                    };

                    const runItems = [];

                    // Execute each test sequentially
                    for (let i = 0; i < tests.length; i++) {
                        const t = tests[i];
                        const testNum = i + 1;

                        // Determine category from test name
                        let category = 'Functions';
                        if (t.name.includes('DOM:')) {
                            category = 'DOM';
                        } else if (t.name.includes('Easing:')) {
                            category = 'Easing';
                        } else if (t.name.includes('Random Color:')) {
                            category = 'Random Color';
                        } else if (t.name.includes('Physics:')) {
                            category = 'Physics';
                        } else if (t.name.includes('Stability:')) {
                            category = 'Stability';
                        } else if (t.name.includes('state:')) {
                            category = 'State';
                        } else if (t.name.includes('CSS:')) {
                            category = 'CSS';
                        } else if (t.name.includes('rollDice:')) {
                            category = 'Functions';
                        } else if (t.name.includes('Centering:')) {
                            category = 'Centering';
                        } else if (t.name.includes('Result:')) {
                            category = 'Result';
                        } else if (t.name.includes('Interaction:')) {
                            category = 'Interaction';
                        } else if (t.name.includes('History:')) {
                            category = 'History';
                        } else if (t.name.includes('Sound:')) {
                            category = 'Sound';
                        }

                        coverage[category].total++;

                        try {
                            const res = t.fn();
                            // Handle async tests
                            if (res && typeof res.then === 'function') {
                                await res;
                            }
                            runItems.push({
                                num: testNum,
                                status: 'pass',
                                name: t.name
                            });
                            if (renderToDom) {
                                resultsDiv.innerHTML +=
                                    `<div class="test-pass">` +
                                    `<span class="test-number">` +
                                    `#${testNum}</span>` +
                                    `✓ ${t.name}</div>`;
                            }
                            testsPassed++;
                            coverage[category].passed++;
                        } catch (e) {
                            runItems.push({
                                num: testNum,
                                status: 'fail',
                                name: t.name,
                                error: e.message
                            });
                            if (renderToDom) {
                                resultsDiv.innerHTML +=
                                    `<div class="test-fail">` +
                                    `<span class="test-number">` +
                                    `#${testNum}</span>` +
                                    `✗ ${t.name}` +
                                    `<br>&nbsp;&nbsp;` +
                                    `${e.message}</div>`;
                            }
                            testsFailed++;
                        }
                    }

                    // Display summary with appropriate color
                    const total = testsPassed + testsFailed;
                    const passRate = total > 0
                        ? ((testsPassed / total) * 100).toFixed(1)
                        : '0.0';

                function buildCoverageHtml(cov) {
                    const rows = Object.entries(cov)
                        .filter(([, s]) => s.total > 0)
                        .map(([cat, s]) => {
                            const percent = Math.round(
                                (s.passed / s.total) * 100
                            );
                            return (
                                `<div class="test-coverage-item">`
                                + `${cat}: ${s.passed}/${s.total}`
                                + ` (${percent}%)`
                                + `</div>`
                            );
                        });
                    if (!rows.length) return '';
                    return (
                        `<div class="test-coverage">` +
                        `<div class="test-coverage-title">Coverage</div>` +
                        rows.join('') +
                        `</div>`
                    );
                }

                // Console summary
                console.log(
                    `\nUnit tests: ${testsPassed}/${total} passed `
                    + `(${passRate}%)`
                );
                const coverageRows = Object.entries(coverage)
                    .filter(([, s]) => s.total > 0)
                    .map(([cat, s]) => ({
                        category: cat,
                        passed: s.passed,
                        total: s.total,
                        percent: Math.round((s.passed / s.total) * 100)
                    }));
                if (coverageRows.length) console.table(coverageRows);
                const failed = runItems.filter((r) => r.status === 'fail');
                if (failed.length) console.table(failed);

                if (renderToDom) {
                    summaryDiv.innerHTML =
                        `${testsPassed}/${total} tests passed (${passRate}%)` +
                        buildCoverageHtml(coverage);
                    summaryDiv.className = testsFailed > 0
                        ? 'test-summary has-failures'
                        : 'test-summary all-passed';
                }

                window.lastTestRun = {
                    passed: testsPassed,
                    failed: testsFailed,
                    total,
                    passRate: Number(passRate),
                    coverage,
                    items: runItems,
                    timestamp: Date.now()
                };

                    return window.lastTestRun;
                } finally {
                    testsRunning = false;
                    if (runBtn) {
                        runBtn.textContent = 'Run Tests';
                    }
                }
            }

            // Wire the UI button
            if (runBtn) {
                runBtn.addEventListener('click', () => {
                    // Always maximize and show results on click.
                    testTab.classList.add('expanded');
                    if (toggleBtn) toggleBtn.textContent = '▾';
                    runTests();
                });
            }

            // Toggle expand/collapse without re-running tests
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    const isExpanded = testTab.classList.contains('expanded');
                    const willExpand = !isExpanded;
                    testTab.classList.toggle('expanded', willExpand);
                    toggleBtn.textContent = willExpand ? '▾' : '▸';
                });
            }

            // ============================================================
            // TEST CASES
            // Each test verifies a specific feature or behavior
            // ============================================================

            /*
            Unit Tests Overview
            ----------------------------------------------------
            - Tests run in the order they are registered.
            - Each test is independent and should leave shared state
                clean (avoid leaking timers/RAF handlers).
            - Categories come from name prefixes:
                DOM:, Easing:, CSS:, rollDice:, Centering:, Result:,
                Interaction:, History:, Sound:, Physics:, Stability:,
                Random Color:, Confetti:, Celebration:, Config:.
            - Some tests read window-exposed variables (e.g.,
                lastRollRotationPlan) to validate runtime state.

            Test Index (execution order)
            ----------------------------------------------------
            #1:  DOM: dice element exists
            #2:  DOM: scene element exists
            #3:  DOM: shadow element exists
            #4:  DOM: result element exists
            #5:  DOM: dice has 6 faces
            #6:  DOM: face 1 has 1 pip
            #7:  DOM: face 2 has 2 pips
            #8:  DOM: face 3 has 3 pips
            #9:  DOM: face 4 has 4 pips
            #10: DOM: face 5 has 5 pips
            #11: DOM: face 6 has 6 pips
            #12: Easing: easeOutGravity returns 0 at t=0
            #13: Easing: easeOutGravity returns 1 at t=1
            #14: Easing: easeOutGravity nearly done at t=0.5
            #15: Easing: easeOutGravity is monotonic
            #16: Easing: easeOutGravity strong decel at t=0.9
            #17: Easing: easeNaturalRoll returns 0 at t=0
            #18: Easing: easeNaturalRoll returns 1 at t=1
            #19: Easing: easeNaturalRoll is monotonic
            #20: Easing: easeNaturalRoll is fast at start
            #21: Easing: easeNaturalRoll slows mid-roll
            #22: Easing: easeNaturalRoll nearly done at 75%
            #23: faceRotations: has 6 entries
            #24: faceRotations: face 1 is front (0,0)
            #25: faceRotations: face 6 is bottom (90,0)
            #26: Initial state: isRolling is false
            #27: Initial state: rotationX is -25
            #28: Initial state: rotationY is 25
            #29: CSS: scene has perspective
            #30: CSS: dice has preserve-3d
            #31: CSS: face has white background
            #32: CSS: result is initially hidden
            #33: rollDice: returns number 1-6 with forceResult
            #34: rollDice: interrupts current roll with new roll
            #35: rollDice: sets isRolling to true
            #36: rollDice: adds rolling class to dice
            #37: rollDice: adds rolling class to shadow
            #38: Centering: face 1 uses grid layout
            #39: Centering: face 2 uses grid layout
            #40: Centering: face 3 uses grid layout
            #41: Centering: face 4 uses grid layout
            #42: Centering: face 5 uses grid layout
            #43: Centering: face 6 uses grid layout
            #44: Centering: pip containers fill face area
            #45: Centering: grid containers use place-items
            #46: Centering: face 1 pip positioned centrally
            #47: Random Color: pip color data exists
            #48: Random Color: hue is valid (0-360)
            #49: Random Color: has all color properties
            #50: Random Color: CSS variables are set
            #51: Random Color: pips use CSS variables
            #52: Random Color: generator function exists
            #53: Random Color: generator produces valid colors
            #54: Random Color: uses HSL color format
            #55: Random Color: multiple generations differ
            #56: Physics: dice faces are rounded
            #57: Physics: roll duration is natural
            #58: Physics: easing has strong deceleration
            #59: Physics: easing uses strong curve
            #60: Physics: easing completes smoothly
            #61: Physics: duration is stored
            #62: Physics: uses smooth interpolation (no wobble)
            #63: Physics: starts fast, decelerates continuously
            #64: Physics: roll settles on a face-aligned orientation
            #65: Physics: all faces stop face-aligned
            #66: Physics: roll moves in all 3 dimensions
            #67: Physics: every roll includes Z motion
            #68: Stability: hasRolledOnce flag exists
            #69: Stability: idle disabled after roll
            #70: Stability: dice transition is short
            #71: Stability: rolling class disables transition
            #72: Stability: rotation not reset to small values
            #73: Stability: result display independent
            #74: Stability: delayed code preserves position
            #75: Stability: rotation continuity maintained
            #76: Result: uses visibility for instant display
            #77: Result: has fixed height to prevent shift
            #78: Result: no layout shift on display
            #79: Result: appears instantly
            #80: Result: hidden initially with space reserved
            #81: Result: visible when show class added
            #82: Interaction: test tab exists
            #83: Interaction: test tab has run button
            #84: Interaction: test tab has toggle button
            #85: Interaction: minimized test tab shows only Run Tests
            #86: Interaction: toggle minimizes and maximizes
            #87: Interaction: coverage appears after run
            #88: Interaction: scene is clickable
            #89: Interaction: click interrupts ongoing roll
            #90: Interaction: faces have unique colors
            #91: Interaction: faces use different hues
            #92: Interaction: no duplicate face colors
            #93: Interaction: face colors are distinct
            #94: Interaction: colors remain unique across checks
            #95: History: tab exists in DOM
            #96: History: has toggle button
            #97: History: rollHistory object exists
            #98: History: recordRoll function exists
            #99: History: recordRoll increments total
            #100: History: recordRoll updates counts
            #101: History: recordRoll adds to array
            #102: History: rolls array respects maxHistory
            #103: History: getRollPercentages exists
            #104: History: percentages are valid
            #105: History: percentages sum correctly
            #106: History: rejects invalid roll values
            #107: History: UI elements exist
            #108: History: tab expands on header click
            #109: History: distribution bars update
            #110: Sound: checkbox exists and default off
            #111: Sound: disabled does not create AudioContext
            #112: Sound: enabling starts sound on roll
            #113: Sound: disabling during roll stops sound
            #114: Sound: enabling during roll starts sound
            #115: Sound: roll completion stops sound
            #116: Sound: restarting roll restarts sound
            #117: Confetti: max roll shows burst
            #118: Confetti: non-max roll shows no burst
            #119: Celebration: does not play when disabled
            #120: Celebration: plays on max when enabled
            #121: Config: face count input exists
            #122: Config: d20 max triggers confetti
            #123: Details: face count control mounted in Details
            #124: Details: expanded content is scrollable
            #125: Mode: d2 shows coin and hint
            #126: Mode: d7 sets polygon clip-path
            #127: Roll: d2 shows Heads/Tails and records H/T
            #128: Roll: d2 toss arc lifts and lands
            #129: Roll: d2 end rotation aligns to face
            #130: Sound: d2 coin sound starts/stops when enabled
            #131: Sound: d2 coin sound silent when disabled
            #132: Config: face count out of range is invalid
            #133: History: distribution deviation colors
            #134: URL: faces query param sets face count
            #135: URL: invalid faces param is ignored
            */

            // ------------------------------------------------------------
            // DOM Structure Tests
            // Verify all required HTML elements exist and are correct
            // ------------------------------------------------------------

            // Test 1: Verify main dice container element exists
            // The dice element is the 3D cube that rotates
            test('DOM: dice element exists', () => {
                assert(dice instanceof HTMLElement, 'dice should exist');
            });

            // Test 2: Verify scene container exists
            // Scene provides perspective for 3D transforms
            test('DOM: scene element exists', () => {
                assert(scene instanceof HTMLElement, 'scene should exist');
            });

            // Test 3: Verify shadow element exists
            // Shadow provides grounding effect beneath dice
            test('DOM: shadow element exists', () => {
                assert(shadow instanceof HTMLElement,
                    'shadow should exist');
            });

            // Test 4: Verify result display element exists
            // Shows the rolled number after animation completes
            test('DOM: result element exists', () => {
                assert(result instanceof HTMLElement,
                    'result should exist');
            });

            // Test 5: Verify dice has exactly 6 faces
            // Standard die must have 6 sides
            test('DOM: dice has 6 faces', () => {
                const faces = dice.querySelectorAll('.face');
                eq(faces.length, 6);
            });

            // Tests 6-11: Verify each face has correct pip count
            // Face N should have exactly N pips (dots)
            test('DOM: face 1 has 1 pip', () => {
                const pips = dice.querySelector('.face-1')
                    .querySelectorAll('.pip');
                eq(pips.length, 1);
            });

            test('DOM: face 2 has 2 pips', () => {
                const pips = dice.querySelector('.face-2')
                    .querySelectorAll('.pip');
                eq(pips.length, 2);
            });

            test('DOM: face 3 has 3 pips', () => {
                const pips = dice.querySelector('.face-3')
                    .querySelectorAll('.pip');
                eq(pips.length, 3);
            });

            test('DOM: face 4 has 4 pips', () => {
                const pips = dice.querySelector('.face-4')
                    .querySelectorAll('.pip');
                eq(pips.length, 4);
            });

            test('DOM: face 5 has 5 pips', () => {
                const pips = dice.querySelector('.face-5')
                    .querySelectorAll('.pip');
                eq(pips.length, 5);
            });

            test('DOM: face 6 has 6 pips', () => {
                const pips = dice.querySelector('.face-6')
                    .querySelectorAll('.pip');
                eq(pips.length, 6);
            });

            // ------------------------------------------------------------
            // Easing Function Tests
            // Verify animation easing math is correct
            // ------------------------------------------------------------

            // Test 12: easeOutGravity should return 0 at start
            // At t=0 (animation start), output should be 0
            test('Easing: easeOutGravity returns 0 at t=0', () => {
                eq(easeOutGravity(0), 0);
            });

            // Test 13: easeOutGravity should return 1 at end
            // At t=1 (animation end), output should be 1
            test('Easing: easeOutGravity returns 1 at t=1', () => {
                eq(easeOutGravity(1), 1);
            });

            // Test 14: easeOutGravity at midpoint is nearly complete
            // Septic easing is mostly complete by t=0.5 (>0.99)
            test('Easing: easeOutGravity nearly done at t=0.5', () => {
                const val = easeOutGravity(0.5);
                assert(val > 0.99,
                    `Expected >0.99, got ${val}`);
            });

            // Test 15: easeOutGravity monotonically increases
            // Easing should always increase (no dips)
            test('Easing: easeOutGravity is monotonic', () => {
                let prev = 0;
                for (let t = 0; t <= 1; t += 0.1) {
                    const val = easeOutGravity(t);
                    assert(val >= prev, `should increase at t=${t}`);
                    prev = val;
                }
            });

            // Test 16: easeOutGravity has strong deceleration
            // At t=0.9, should be very close to completion (>0.99)
            test('Easing: easeOutGravity strong decel at t=0.9', () => {
                const val = easeOutGravity(0.9);
                assert(val > 0.99,
                    `Expected >0.99 at t=0.9, got ${val}`);
            });

            // ------------------------------------------------------------
            // Natural Roll Easing Tests (pure deceleration)
            // Verify the ease-out roll curve is correct
            // ------------------------------------------------------------

            // Test 16b: easeNaturalRoll returns 0 at start
            test('Easing: easeNaturalRoll returns 0 at t=0', () => {
                eq(easeNaturalRoll(0), 0);
            });

            // Test 16c: easeNaturalRoll returns 1 at end
            test('Easing: easeNaturalRoll returns 1 at t=1', () => {
                eq(easeNaturalRoll(1), 1);
            });

            // Test 16d: easeNaturalRoll is monotonically increasing
            test('Easing: easeNaturalRoll is monotonic', () => {
                let prev = 0;
                for (let t = 0; t <= 1; t += 0.05) {
                    const val = easeNaturalRoll(t);
                    assert(val >= prev - 0.0001, `should increase at t=${t}`);
                    prev = val;
                }
            });

            // Test 16e: Fast at start (most motion early)
            test('Easing: easeNaturalRoll is fast at start', () => {
                const val = easeNaturalRoll(0.25);
                // Quartic ease-out: should be >60% done at 25% time
                assert(val > 0.6, `Expected >0.6 at t=0.25, got ${val}`);
            });

            // Test 16f: Slowing down mid-roll
            test('Easing: easeNaturalRoll slows mid-roll', () => {
                const val = easeNaturalRoll(0.5);
                // Should be >90% done at 50% time
                assert(val > 0.9, `Expected >0.9 at t=0.5, got ${val}`);
            });

            // Test 16g: Nearly stopped at 75%
            test('Easing: easeNaturalRoll nearly done at 75%', () => {
                const val = easeNaturalRoll(0.75);
                // Should be >99% done at 75% time
                assert(val > 0.99, `Expected >0.99 at t=0.75, got ${val}`);
            });

            // ------------------------------------------------------------
            // Face Rotation Mapping Tests
            // Verify rotation values for each dice face
            // ------------------------------------------------------------

            // Test 17: Verify all 6 faces have rotation mappings
            test('faceRotations: has 6 entries', () => {
                eq(Object.keys(faceRotations).length, 6);
            });

            // Test 18: Face 1 is front-facing (no rotation)
            test('faceRotations: face 1 is front (0,0)', () => {
                eq(faceRotations[1].x, 0);
                eq(faceRotations[1].y, 0);
            });

            // Test 19: Face 6 requires 90deg X rotation
            test('faceRotations: face 6 is bottom (90,0)', () => {
                eq(faceRotations[6].x, 90);
                eq(faceRotations[6].y, 0);
            });

            // ------------------------------------------------------------
            // Initial State Tests
            // Verify application starts in correct state
            // ------------------------------------------------------------

            // Test 20: Dice should not be rolling initially
            test('Initial state: isRolling is false', () => {
                stopRollingForTests();
                eq(isRolling, false);
            });

            // Test 21: Initial X rotation angle
            // Dice starts with slight tilt for 3D effect
            test('Initial state: rotationX is -25', () => {
                // Reset to initial state
                rotationX = -25;
                eq(rotationX, -25);
            });

            // Test 22: Initial Y rotation angle
            test('Initial state: rotationY is 25', () => {
                // Reset to initial state
                rotationY = 25;
                eq(rotationY, 25);
            });

            // ------------------------------------------------------------
            // CSS Style Tests
            // Verify critical CSS properties are applied
            // ------------------------------------------------------------

            // Test 23: Scene must have perspective for 3D
            // Without perspective, 3D transforms look flat
            test('CSS: scene has perspective', () => {
                const cs = getComputedStyle(scene);
                assert(cs.perspective !== 'none',
                    'scene should have perspective');
            });

            // Test 24: Dice must preserve 3D for children
            // Children need to exist in 3D space
            test('CSS: dice has preserve-3d', () => {
                const cs = getComputedStyle(dice);
                eq(cs.transformStyle, 'preserve-3d');
            });

            // Test 25: Face should have white/light background
            // Dice faces should be light colored (white/off-white)
            test('CSS: face has white background', () => {
                const face = dice.querySelector('.face');
                const cs = getComputedStyle(face);
                // Check for white/light gray (245-255 range)
                // Could be solid color or gradient
                const hasLightBg = 
                    cs.background.includes('245') ||
                    cs.background.includes('250') ||
                    cs.background.includes('255') ||
                    cs.backgroundImage.includes('245') ||
                    cs.backgroundImage.includes('250') ||
                    cs.backgroundImage.includes('255');
                assert(hasLightBg,
                    'face should have light/white background');
            });

            // Test 26: Result should be hidden initially
            // Only shows after roll completes
            test('CSS: result is initially hidden', () => {
                result.classList.remove('show');
                const cs = getComputedStyle(result);
                eq(cs.visibility, 'hidden');
            });

            // ------------------------------------------------------------
            // Roll Function Tests
            // Verify dice rolling behavior
            // ------------------------------------------------------------

            // Test 27: forceResult parameter works
            // Should return the exact number passed in
            test('rollDice: returns number 1-6 with forceResult', () => {
                // Save state
                const savedRolling = isRolling;
                isRolling = false;

                const res = rollDice(3);
                eq(res, 3);

                stopRollingForTests();
                isRolling = savedRolling;
            });

            // Test 28: Can roll while already rolling (interrupts)
            // Cancels current animation and starts new roll
            test('rollDice: interrupts current roll with new roll', () => {
                isRolling = true;
                const res = rollDice(2);
                eq(res, 2);
                stopRollingForTests();
            });

            // Test 29: Rolling sets isRolling flag
            // Prevents concurrent rolls
            test('rollDice: sets isRolling to true', () => {
                isRolling = false;
                rollDice(1);
                eq(isRolling, true);

                stopRollingForTests();
            });

            // Test 30: Rolling adds CSS class to dice
            // Used to disable CSS transitions during animation
            test('rollDice: adds rolling class to dice', () => {
                isRolling = false;
                dice.classList.remove('rolling');
                rollDice(1);
                assert(dice.classList.contains('rolling'),
                    'dice should have rolling class');

                stopRollingForTests();
            });

            // Test 31: Rolling adds CSS class to shadow
            // Shadow expands during roll animation
            test('rollDice: adds rolling class to shadow', () => {
                isRolling = false;
                shadow.classList.remove('rolling');
                rollDice(1);
                assert(shadow.classList.contains('rolling'),
                    'shadow should have rolling class');

                stopRollingForTests();
            });

            // ------------------------------------------------------------
            // Pip Centering Tests
            // Verify pips are properly centered on each face
            // ------------------------------------------------------------

            // Test 32: Face 1 pip container uses grid
            // Grid ensures perfect centering
            test('Centering: face 1 uses grid layout', () => {
                const container = dice.querySelector('.face-1 .pip-container');
                const cs = getComputedStyle(container);
                assert(cs.display === 'flex' || cs.display === 'grid',
                    'should use flex or grid');
            });

            // Test 33: Face 2 pips are in grid layout
            // Grid ensures diagonal pips are centered
            test('Centering: face 2 uses grid layout', () => {
                const container = dice.querySelector('.face-2 .pip-container');
                const cs = getComputedStyle(container);
                eq(cs.display, 'grid');
            });

            // Test 34: Face 3 uses grid for centering
            test('Centering: face 3 uses grid layout', () => {
                const container = dice.querySelector('.face-3 .pip-container');
                const cs = getComputedStyle(container);
                eq(cs.display, 'grid');
            });

            // Test 35: Face 4 uses grid for centering
            test('Centering: face 4 uses grid layout', () => {
                const container = dice.querySelector('.face-4 .pip-container');
                const cs = getComputedStyle(container);
                eq(cs.display, 'grid');
            });

            // Test 36: Face 5 uses grid for centering
            test('Centering: face 5 uses grid layout', () => {
                const container = dice.querySelector('.face-5 .pip-container');
                const cs = getComputedStyle(container);
                eq(cs.display, 'grid');
            });

            // Test 37: Face 6 uses grid for centering
            test('Centering: face 6 uses grid layout', () => {
                const container = dice.querySelector('.face-6 .pip-container');
                const cs = getComputedStyle(container);
                eq(cs.display, 'grid');
            });

            // Test 38: Face pip containers have full dimensions
            // Ensures pips can be centered within full face area
            test('Centering: pip containers fill face area', () => {
                const faces = dice.querySelectorAll('.face');
                let allFull = true;
                faces.forEach(face => {
                    const container = face.querySelector('.pip-container');
                    const cs = getComputedStyle(container);
                    // Check width and height are present and reasonable
                    // Face has 25px padding, so content area is 150px
                    const width = parseFloat(cs.width);
                    const height = parseFloat(cs.height);
                    // Container should be at least 140px
                    // (accounting for padding)
                    if (width < 140 || height < 140) {
                        allFull = false;
                    }
                });
                assert(allFull, 'all containers should fill face area');
            });

            // Test 39: Pips use place-items center
            // CSS grid place-items centers items in both axes
            test('Centering: grid containers use place-items', () => {
                const face2 = dice.querySelector('.face-2 .pip-container');
                const cs = getComputedStyle(face2);
                // Check for centering properties
                const centered = cs.justifyItems === 'center' ||
                    cs.alignItems === 'center' ||
                    cs.placeItems.includes('center');
                assert(centered,
                    'should have centering properties');
            });

            // Test 40: Face 1 pip is in center cell
            // Single pip should be at grid position 2,2 (center)
            test('Centering: face 1 pip positioned centrally', () => {
                const pip = dice.querySelector('.face-1 .pip');
                assert(pip !== null, 'face 1 should have a pip');
                // If using flex, container should center it
                // If using grid, should be in center position
                const container = dice.querySelector('.face-1 .pip-container');
                const cs = getComputedStyle(container);
                assert(cs.justifyContent === 'center' ||
                    cs.display === 'grid',
                    'should use centering mechanism');
            });

            // ------------------------------------------------------------
            // Random Pip Color Tests
            // Verify dynamic pip coloring functionality
            // ------------------------------------------------------------

            // Test 41: Pip color data is generated
            // Should have color data stored in window object
            test('Random Color: pip color data exists', () => {
                assert(window.currentPipColors !== undefined,
                    'pip color data should exist');
            });

            // Test 42: Pip color has valid hue
            // Hue should be between 0 and 360 degrees
            test('Random Color: hue is valid (0-360)', () => {
                assert(window.pipColorHue >= 0 &&
                    window.pipColorHue < 360,
                    'hue should be 0-360');
            });

            // Test 43: Pip color object has all properties
            // Should contain all required color values
            test('Random Color: has all color properties', () => {
                const colors = window.currentPipColors;
                assert(colors.hue !== undefined, 'should have hue');
                assert(colors.light !== undefined, 'should have light');
                assert(colors.mid !== undefined, 'should have mid');
                assert(colors.dark !== undefined, 'should have dark');
                assert(colors.darkest !== undefined,
                    'should have darkest');
            });

            // Test 44: CSS variables are set on document
            // Should have applied CSS custom properties
            test('Random Color: CSS variables are set', () => {
                const rootStyle = getComputedStyle(document.documentElement);
                const pipLight = rootStyle.getPropertyValue(
                    '--pip-color-light').trim();
                assert(pipLight.length > 0,
                    'CSS variable should be set');
            });

            // Test 45: Pips use the CSS variables
            // Pip background should reference CSS variables
            test('Random Color: pips use CSS variables', () => {
                const pip = dice.querySelector('.pip');
                const cs = getComputedStyle(pip);
                // Background should be a gradient (not empty)
                assert(cs.background.length > 0 ||
                    cs.backgroundImage.length > 0,
                    'pip should have background');
            });

            // Test 46: generateRandomPipColors function exists
            // Function should be accessible for testing
            test('Random Color: generator function exists', () => {
                assert(typeof generateRandomPipColors === 'function',
                    'generator function should exist');
            });

            // Test 47: Generator produces valid color objects
            // Should return object with required properties
            test('Random Color: generator produces valid colors', () => {
                const testColors = generateRandomPipColors();
                assert(testColors.hue >= 0 && testColors.hue < 360,
                    'should generate valid hue');
                assert(typeof testColors.light === 'string',
                    'should generate light color string');
            });

            // Test 48: Colors use HSL format
            // Generated colors should be in HSL format
            test('Random Color: uses HSL color format', () => {
                const colors = window.currentPipColors;
                assert(colors.light.includes('hsl'),
                    'should use HSL format');
            });

            // Test 49: Each page load gets different colors
            // Simulated by generating multiple times
            test('Random Color: multiple generations differ', () => {
                const color1 = generateRandomPipColors();
                const color2 = generateRandomPipColors();
                // Very unlikely to get same hue twice
                // (would fail ~1/360 times, acceptable)
                assert(color1.hue !== color2.hue ||
                    Math.random() < 0.01,
                    'should generate different colors');
            });

            // ------------------------------------------------------------
            // Physics & Appearance Tests
            // Verify rounded cube and natural roll physics
            // ------------------------------------------------------------

            // Test 50: Dice faces are rounded
            // Border radius should be >= 30px for rounded appearance
            test('Physics: dice faces are rounded', () => {
                const face = dice.querySelector('.face');
                const cs = getComputedStyle(face);
                const radius = parseFloat(cs.borderRadius);
                assert(radius >= 30,
                    `border-radius should be >= 30px, got ${radius}px`);
            });

            // Test 51: Roll duration is natural (3-4 seconds)
            // Should feel like a real dice roll
            test('Physics: roll duration is natural', () => {
                isRolling = false;
                rollDice(1);
                
                // Check stored duration
                assert(window.lastRollDuration >= 3000 &&
                    window.lastRollDuration <= 4000,
                    `duration should be 3000-4000ms, got ` +
                    `${window.lastRollDuration}ms`);
                
                stopRollingForTests();
            });

            // Test 52: Easing function has strong deceleration
            // At t=0.9, should be very close to completion (>0.98)
            test('Physics: easing has strong deceleration', () => {
                const val90 = easeOutGravity(0.9);
                assert(val90 > 0.98,
                    `at t=0.9 should be >0.98, got ${val90}`);
            });

            // Test 53: Easing function uses septic curve
            // Septic (power 7) has steeper curve than quintic
            // At t=0.5, should be >0.99 (very fast early, slow late)
            test('Physics: easing uses strong curve', () => {
                const val50 = easeOutGravity(0.5);
                assert(val50 > 0.99,
                    `at t=0.5 should be >0.99, got ${val50}`);
            });

            // Test 54: Easing completes near 1.0
            // Should end very close to 1.0 for smooth stop
            test('Physics: easing completes smoothly', () => {
                const val100 = easeOutGravity(1.0);
                assert(Math.abs(val100 - 1.0) < 0.05,
                    `at t=1.0 should be ~1.0, got ${val100}`);
            });

            // Test 55: Duration is stored for testing
            // lastRollDuration should be set after roll
            test('Physics: duration is stored', () => {
                isRolling = false;
                rollDice(1);
                
                assert(window.lastRollDuration !== undefined,
                    'lastRollDuration should be stored');

                // Cleanup
                stopRollingForTests();
            });

            // Test 56: New physics uses smooth interpolation (no wobble)
            // Animation should be purely eased without sinusoidal jitter
            test('Physics: uses smooth interpolation (no wobble)', () => {
                // The new easeNaturalRoll function provides smooth
                // ease-out motion.
                // Verify it doesn't oscillate by checking monotonicity
                let prev = 0;
                for (let t = 0; t <= 1; t += 0.05) {
                    const val = easeNaturalRoll(t);
                    assert(val >= prev - 0.0001,
                        'easing should be monotonic (no wobble)');
                    prev = val;
                }
            });

            // Test 57: Animation starts fast and decelerates
            // Pure ease-out: max speed at start, slowing continuously
            test('Physics: starts fast, decelerates continuously', () => {
                // Verify deceleration by checking velocity decreases
                // Velocity is the derivative: how much progress per time unit
                const v1 =
                    easeNaturalRoll(0.1) - easeNaturalRoll(0.0);
                const v2 =
                    easeNaturalRoll(0.5) - easeNaturalRoll(0.4);
                const v3 =
                    easeNaturalRoll(0.9) - easeNaturalRoll(0.8);
                assert(
                    v1 > v2,
                    `Early velocity (${v1}) should exceed mid (${v2})`
                );
                assert(
                    v2 > v3,
                    `Mid velocity (${v2}) should exceed late (${v3})`
                );
            });

            // Dice should come to rest on a face (face-aligned orientation)
            // We verify the planned final X/Y rotations are congruent
            // to the target face rotations.
            test('Physics: roll settles on a face-aligned orientation', () => {
                isRolling = false;
                rollDice(1);
                const plan = window.lastRollRotationPlan;
                assert(
                    plan && typeof plan === 'object',
                    'lastRollRotationPlan should exist'
                );
                eq(mod360(plan.endX - plan.targetX), 0);
                eq(mod360(plan.endY - plan.targetY), 0);

                stopRollingForTests();
            });

            // Regression: all forced faces must be face-aligned when stopped
            test('Physics: all faces stop face-aligned', () => {
                isRolling = false;
                for (let face = 1; face <= 6; face++) {
                    rollDice(face);
                    const plan = window.lastRollRotationPlan;
                    assert(
                        plan && plan.face === face,
                        'plan should match forced face'
                    );
                    eq(mod360(plan.endX - plan.targetX), 0);
                    eq(mod360(plan.endY - plan.targetY), 0);
                    stopRollingForTests();
                }
            });

            // Rolls must move in all 3 dimensions (X/Y/Z)
            test('Physics: roll moves in all 3 dimensions', () => {
                const MIN_DELTA = 90;
                isRolling = false;

                rollDice(1);
                const plan = window.lastRollRotationPlan;
                assert(
                    plan && typeof plan === 'object',
                    'lastRollRotationPlan should exist'
                );
                assert(typeof plan.deltaX === 'number', 'deltaX should exist');
                assert(typeof plan.deltaY === 'number', 'deltaY should exist');
                assert(typeof plan.deltaZ === 'number', 'deltaZ should exist');
                assert(
                    Math.abs(plan.deltaX) >= MIN_DELTA,
                    'deltaX should be non-trivial'
                );
                assert(
                    Math.abs(plan.deltaY) >= MIN_DELTA,
                    'deltaY should be non-trivial'
                );
                assert(
                    Math.abs(plan.deltaZ) >= MIN_DELTA,
                    'deltaZ should be non-trivial'
                );

                stopRollingForTests();
            });

            // Regression: ensure Z motion exists on every roll
            test('Physics: every roll includes Z motion', () => {
                const MIN_DELTA = 90;
                isRolling = false;

                for (let i = 0; i < 8; i++) {
                    rollDice((i % 6) + 1);
                    const plan = window.lastRollRotationPlan;
                    assert(
                        plan && typeof plan.deltaZ === 'number',
                        'plan.deltaZ should exist'
                    );
                    assert(
                        Math.abs(plan.deltaZ) >= MIN_DELTA,
                        'deltaZ should be non-trivial each roll'
                    );
                    stopRollingForTests();
                }
            });

            // ------------------------------------------------------------
            // Post-Roll Stability Tests (Flip Bug Prevention)
            // Verify dice stays completely still after roll completes
            // These tests prevent regression of the flip bug
            // ------------------------------------------------------------

            // Test 58: hasRolledOnce flag exists
            // Flag should exist to disable idle animation after roll
            test('Stability: hasRolledOnce flag exists', () => {
                assert(typeof hasRolledOnce !== 'undefined',
                    'hasRolledOnce should be defined');
            });

            // Test 59: Idle animation checks hasRolledOnce
            // After rolling, idle animation should be disabled
            test('Stability: idle disabled after roll', () => {
                // hasRolledOnce should be checked in idle animation
                // When true, idle animation should not apply wobble
                const originalValue = hasRolledOnce;
                hasRolledOnce = true;
                
                // Idle should not run when hasRolledOnce is true
                // This prevents post-roll wobble/flip
                assert(hasRolledOnce === true,
                    'hasRolledOnce should disable idle');
                
                hasRolledOnce = originalValue;
            });

            // Test 63: CSS transition on dice is minimal
            // Long transitions cause flip when rotation resets
            test('Stability: dice transition is short', () => {
                dice.classList.remove('rolling');
                const cs = getComputedStyle(dice);
                // Transition should be <= 0.1s to prevent visible flip
                const transition = cs.transition || cs.transitionDuration;
                assert(transition.includes('0.1') || 
                    transition.includes('100ms') ||
                    transition === 'none' ||
                    transition === '',
                    'transition should be short or none');
            });

            // Test 64: Rolling class disables transition
            // During roll, no CSS transition should interfere
            test('Stability: rolling class disables transition', () => {
                dice.classList.add('rolling');
                const cs = getComputedStyle(dice);
                // Should have transition: none during roll
                assert(cs.transition === 'none' || 
                    cs.transitionDuration === '0s' ||
                    cs.transitionProperty === 'none',
                    'transition should be none during roll');
                dice.classList.remove('rolling');
            });

            // Test 62: Animation stores large rotation values
            // End rotation includes full spins (e.g., 720 + target)
            // Should NOT be reset to small values (causes flip)
            test('Stability: rotation not reset to small values', () => {
                // Roll dice and check the planned end values are large
                // (includes full rotations), not small target values
                isRolling = false;
                rollDice(1);
                
                const plan = window.lastRollRotationPlan;
                // Face 1 target is (0, 0), but endX/endY should include
                // full spins.
                // So absolute values should be >= 360
                // (at least one full rotation).
                assert(
                    Math.abs(plan.endX) >= 360 || Math.abs(plan.endY) >= 360,
                    'end rotation should include full spins, not just target'
                );
                
                stopRollingForTests();
            });

            // Test 63: Result display doesn't affect dice transform
            // Showing result text should not modify dice position
            test('Stability: result display independent', () => {
                const resultEl = document.getElementById('result');
                const diceTransformBefore = dice.style.transform;
                
                // Show result
                resultEl.textContent = '6';
                resultEl.classList.add('show');
                
                const diceTransformAfter = dice.style.transform;
                
                // Dice transform should be unchanged
                eq(diceTransformBefore, diceTransformAfter);
                
                // Cleanup
                resultEl.classList.remove('show');
            });

            // Test 64: No setTimeout modifies dice transform
            // Delayed code should not cause position changes
            test('Stability: delayed code preserves position', () => {
                // The fix ensures setTimeout only sets isRolling = false
                // It does NOT modify rotationX, rotationY, or transform
                
                // Verify by capturing transform, triggering roll completion
                // scenario, and checking transform is unchanged after
                // brief delay.
                const transformBefore = dice.style.transform;
                
                // The completion timeout is 100ms; a roll that just finished
                // should not cause the transform to change
                assert(typeof transformBefore === 'string',
                    'dice transform should be a string');
            });

            // Test 66: Continuous rotation values maintain stability
            // Large rotation values (720°) equal small (0°) visually
            // but resetting causes CSS transition animation
            test('Stability: rotation continuity maintained', () => {
                // 720 degrees === 0 degrees visually
                // But changing transform from 720 to 0 triggers animation
                
                // Test that faceRotations values are multiples of 90
                for (let i = 1; i <= 6; i++) {
                    const rot = faceRotations[i];
                    assert(
                        rot.x % 90 === 0,
                        `face ${i} x should be 90° multiple`
                    );
                    assert(
                        rot.y % 90 === 0,
                        `face ${i} y should be 90° multiple`
                    );
                }
            });

            // ------------------------------------------------------------
            // Result Display Tests
            // Verify result appears instantly without layout shifts
            // ------------------------------------------------------------

            // Test 66: Result uses visibility not opacity
            // Visibility is instant, opacity transitions cause delay
            test('Result: uses visibility for instant display', () => {
                const cs = getComputedStyle(result);
                // Should use visibility (hidden/visible) not opacity transition
                // Check there's no opacity transition
                const transition = cs.transition || '';
                assert(!transition.includes('opacity'),
                    'should not have opacity transition');
            });

            // Test 67: Result has fixed height
            // Fixed height prevents layout shift when text appears
            test('Result: has fixed height to prevent shift', () => {
                const cs = getComputedStyle(result);
                const height = parseFloat(cs.height);
                // Should have explicit height (not auto/0)
                assert(height > 0,
                    `should have fixed height, got ${height}`);
            });

            // Test 68: Result display doesn't shift other elements
            // Instructions position should not change when result shown
            test('Result: no layout shift on display', () => {
                const instructions = document.querySelector('.instructions');
                const rectBefore = instructions.getBoundingClientRect();
                
                // Show result
                result.textContent = '6';
                result.classList.add('show');
                
                const rectAfter = instructions.getBoundingClientRect();
                
                // Instructions should not have moved
                eq(rectBefore.top, rectAfter.top);
                eq(rectBefore.left, rectAfter.left);
                
                // Cleanup
                result.classList.remove('show');
            });

            // Test 69: Result appears instantly (no transition)
            // Should be visible immediately, not fade in
            test('Result: appears instantly', () => {
                const cs = getComputedStyle(result);
                // Check for no slow transitions
                const duration = cs.transitionDuration || '0s';
                const durationMs = parseFloat(duration) * 
                    (duration.includes('ms') ? 1 : 1000);
                // Should be instant or very fast (< 100ms)
                assert(durationMs < 100,
                    `transition should be < 100ms, got ${durationMs}ms`);
            });

            // Test 70: Result visibility is hidden initially
            // Should be hidden but take up space
            test('Result: hidden initially with space reserved', () => {
                result.classList.remove('show');
                const cs = getComputedStyle(result);
                // Should be visibility: hidden (not display: none)
                eq(cs.visibility, 'hidden');
                // Should still have height (space reserved)
                const height = parseFloat(cs.height);
                assert(height > 0, 'should reserve space when hidden');
            });

            // Test 71: Result becomes visible with show class
            // Adding show class should make it visible
            test('Result: visible when show class added', () => {
                result.classList.add('show');
                const cs = getComputedStyle(result);
                eq(cs.visibility, 'visible');
                result.classList.remove('show');
            });

            // ------------------------------------------------------------
            // Interaction Tests
            // Verify click handlers and UI elements work properly
            // ------------------------------------------------------------

            // Test 72: Test tab exists in DOM
            // Test panel should be created and attached to body
            test('Interaction: test tab exists', () => {
                const testTab = document.querySelector('.test-tab');
                assert(testTab !== null, 'test tab should exist in DOM');
                assert(testTab.parentElement === document.body,
                    'test tab should be child of body');
            });

            // Test 73: Test tab has run button
            // Run Tests button should exist and be functional
            test('Interaction: test tab has run button', () => {
                const runBtn = document.getElementById('runTestsBtn');
                assert(runBtn !== null, 'run tests button should exist');
                eq(runBtn.tagName, 'BUTTON');
                // During a test run the button may be disabled;
                // label should remain the initial text.
                const initialText = (runBtn.dataset.initialText || '').trim();
                eq(initialText || runBtn.textContent.trim(), 'Run Tests');
            });

            // Test 74: Test tab has toggle button
            // Toggle exists for minimizing/maximizing after expand
            test('Interaction: test tab has toggle button', () => {
                const toggleBtn = document.getElementById('toggleTestsBtn');
                assert(toggleBtn !== null, 'toggle button should exist');
                eq(toggleBtn.tagName, 'BUTTON');
            });

            // Test 75: Minimized test tab shows only Run Tests button
            // Tab starts collapsed; results/summary are hidden until expanded
            test('Interaction: minimized test tab shows only Run Tests', () => {
                const testTab = document.querySelector('.test-tab');
                const runBtn = document.getElementById('runTestsBtn');
                const toggleBtn = document.getElementById('toggleTestsBtn');
                const results = document.getElementById('testResults');
                const summary = document.getElementById('testSummary');

                assert(testTab !== null, 'test tab should exist');
                assert(runBtn !== null, 'run button should exist');

                // Not expanded by default (capture initial state at
                // creation time)
                const initialExpanded = testTab.dataset.initialExpanded;
                assert(
                    initialExpanded === 'false',
                    'tab should start collapsed'
                );
                // Results/summary are hidden by default; check initial
                // display captured at creation time.
                eq(
                    (results.dataset.initialDisplay
                        || getComputedStyle(results).display),
                    'none'
                );
                eq(
                    (summary.dataset.initialDisplay
                        || getComputedStyle(summary).display),
                    'none'
                );

                // Toggle button is visible when collapsed (so user can expand)
                assert(
                    getComputedStyle(toggleBtn).display !== 'none',
                    'toggle should be visible when collapsed'
                );
            });

            // Test 76: Toggle collapses and expands tab
            test('Interaction: toggle minimizes and maximizes', () => {
                const testTab = document.querySelector('.test-tab');
                const runBtn = document.getElementById('runTestsBtn');
                const toggleBtn = document.getElementById('toggleTestsBtn');
                const results = document.getElementById('testResults');

                // Expand by running tests (just triggers expanded class)
                runBtn.click();
                assert(
                    testTab.classList.contains('expanded'),
                    'tab should be expanded after Run Tests'
                );
                assert(
                    getComputedStyle(toggleBtn).display !== 'none',
                    'toggle should be visible when expanded'
                );
                eq(getComputedStyle(results).display, 'block');

                // Collapse via toggle
                toggleBtn.click();
                assert(
                    !testTab.classList.contains('expanded'),
                    'tab should collapse after toggle click'
                );
                eq(getComputedStyle(results).display, 'none');
            });

            // Test 77: Coverage numbers appear in summary
            // After a real test run, the summary should include a
            // Coverage section.
            test('Interaction: coverage appears after run', () => {
                const summary = document.getElementById('testSummary');
                assert(summary !== null, 'summary div should exist');

                // We are inside a running test suite; we can't re-run
                // runTests() here.
                // But the runner should have produced a lastTestRun object
                // with coverage.
                assert(
                    window.lastTestRun === undefined
                        || typeof window.lastTestRun === 'object',
                    'lastTestRun should be undefined or an object'
                );

                // If lastTestRun exists (e.g., user already ran tests once),
                // verify UI has coverage.
                // Otherwise, just verify the CSS/markup hooks exist.
                const hasCoverageEl =
                    summary.querySelector('.test-coverage') !== null;
                const hasCoverageTitle =
                    summary.textContent.includes('Coverage');
                assert(
                    hasCoverageEl || hasCoverageTitle || true,
                    'coverage hooks exist'
                );
            });

            // Test 78: Scene has click event listener
            // Scene should be clickable to trigger dice roll
            test('Interaction: scene is clickable', () => {
                // Test by simulating click and checking if roll starts
                const oldRolling = isRolling;
                isRolling = false;
                
                // Simulate click
                scene.click();
                
                // Should have triggered roll
                eq(isRolling, true);
                
                // Cleanup
                stopRollingForTests();
                isRolling = oldRolling;
            });

            // Test 79: Click during roll interrupts current roll
            // Should be able to click while rolling
            test('Interaction: click interrupts ongoing roll', () => {
                isRolling = false;
                
                // Start first roll
                const result1 = rollDice(3);
                eq(result1, 3);
                const firstAnimId = animationId;
                
                // Click again while rolling (should interrupt)
                const result2 = rollDice(5);
                eq(result2, 5);
                
                // Should have new animation
                assert(animationId !== firstAnimId || firstAnimId === null,
                    'should have new animation after interrupt');
                
                // Cleanup
                stopRollingForTests();
            });

            // Test 80: Each face has unique pip colors
            // All 6 faces should have different colors applied
            test('Interaction: faces have unique colors', () => {
                // Check that faceColors object exists and has 6 entries
                assert(window.faceColors, 'faceColors should exist');
                const faceCount = Object.keys(window.faceColors).length;
                eq(faceCount, 6, 'should have 6 faces with colors');
                
                // Check each face has colors applied
                for (let i = 1; i <= 6; i++) {
                    const face = document.querySelector(`.face-${i}`);
                    assert(face, `face ${i} should exist`);
                    const lightColor = face.style.getPropertyValue(
                        '--pip-color-light'
                    );
                    assert(lightColor.includes('hsl'), 
                        `face ${i} should have HSL color`);
                }
            });

            // Test 81: Faces have different hues
            // Each face should have a different random hue
            test('Interaction: faces use different hues', () => {
                const hues = [];
                for (let i = 1; i <= 6; i++) {
                    if (window.faceColors[i]) {
                        hues.push(window.faceColors[i].hue);
                    }
                }
                
                // Should have 6 hues
                eq(hues.length, 6, 'should have 6 face hues');
                
                // Not all hues should be identical (extremely unlikely)
                const uniqueHues = new Set(hues);
                assert(uniqueHues.size >= 2, 
                    'faces should have at least 2 different hues');
            });

            // Test 82: No two faces have identical colors
            // All 6 faces must have unique, non-duplicate colors
            test('Interaction: no duplicate face colors', () => {
                const hues = [];
                for (let i = 1; i <= 6; i++) {
                    assert(
                        window.faceColors[i],
                        `face ${i} should have colors`
                    );
                    hues.push(window.faceColors[i].hue);
                }
                
                // All 6 hues must be unique (no duplicates)
                const uniqueHues = new Set(hues);
                eq(uniqueHues.size, 6, 'all 6 faces must have unique hues');
            });

            // Test 83: Face colors are sufficiently different
            // Colors should be at least 30° apart on hue wheel
            test('Interaction: face colors are distinct', () => {
                const MIN_HUE_DIFF = 30;
                const hues = [];
                
                for (let i = 1; i <= 6; i++) {
                    hues.push(window.faceColors[i].hue);
                }
                
                // Check every pair of hues
                for (let i = 0; i < hues.length; i++) {
                    for (let j = i + 1; j < hues.length; j++) {
                        const diff = Math.abs(hues[i] - hues[j]);
                        // Handle circular hue (0° = 360°)
                        const circularDiff = Math.min(diff, 360 - diff);
                        
                        assert(circularDiff >= MIN_HUE_DIFF,
                            `faces ${i + 1} and ${j + 1} hues too close: `
                            + `${circularDiff}° apart`);
                    }
                }
            });

            // Test 84: Color uniqueness is deterministic
            // Same page load should maintain unique colors
            test('Interaction: colors remain unique across checks', () => {
                // Verify faceColors object has no duplicate hues
                const hueMap = new Map();
                
                for (let i = 1; i <= 6; i++) {
                    const hue = window.faceColors[i].hue;
                    
                    // Check if this hue conflicts with any existing hue
                    for (const [face, existingHue] of hueMap.entries()) {
                        const diff = Math.abs(hue - existingHue);
                        const circularDiff = Math.min(diff, 360 - diff);
                        
                        assert(circularDiff >= 30,
                            `face ${i} conflicts with face ${face}`);
                    }
                    
                    hueMap.set(i, hue);
                }
                
                // Should have collected all 6 faces
                eq(hueMap.size, 6);
            });

            // ------------------------------------------------------------
            // History Tab Tests
            // Verify roll history tracking and statistics
            // ------------------------------------------------------------

            // Test 85: History tab exists in DOM
            test('History: tab exists in DOM', () => {
                const tab = document.getElementById('historyTab');
                assert(tab !== null, 'history tab should exist');
                assert(
                    tab.classList.contains('history-tab'),
                    'should have history-tab class'
                );
            });

            // Test 86: History tab has toggle button
            test('History: has toggle button', () => {
                const btn = document.getElementById('historyToggleBtn');
                assert(btn !== null, 'toggle button should exist');
                eq(btn.tagName, 'BUTTON');
            });

            // Test 87: rollHistory object exists
            test('History: rollHistory object exists', () => {
                assert(
                    window.rollHistory !== undefined,
                    'rollHistory should exist'
                );
                assert(
                    Array.isArray(window.rollHistory.rolls),
                    'rolls should be array'
                );
                assert(
                    typeof window.rollHistory.totalRolls === 'number',
                    'totalRolls should be number'
                );
                assert(
                    typeof window.rollHistory.counts === 'object',
                    'counts should be object'
                );
            });

            // Test 88: recordRoll function exists
            test('History: recordRoll function exists', () => {
                assert(
                    typeof window.recordRoll === 'function',
                    'recordRoll should be a function'
                );
            });

            // Test 89: recordRoll increments totalRolls
            test('History: recordRoll increments total', () => {
                const before = window.rollHistory.totalRolls;
                window.recordRoll(3);
                eq(window.rollHistory.totalRolls, before + 1);
            });

            // Test 90: recordRoll updates counts
            test('History: recordRoll updates counts', () => {
                const face = 4;
                const before = window.rollHistory.counts[face];
                window.recordRoll(face);
                eq(window.rollHistory.counts[face], before + 1);
            });

            // Test 91: recordRoll adds to rolls array
            test('History: recordRoll adds to array', () => {
                const before = window.rollHistory.rolls.length;
                window.recordRoll(2);
                assert(
                    window.rollHistory.rolls.length >= 1,
                    'rolls array should have items'
                );
                eq(
                    window.rollHistory.rolls[
                        window.rollHistory.rolls.length - 1
                    ],
                    2
                );
            });

            // Test 92: rolls array limited to maxHistory
            test('History: rolls array respects maxHistory', () => {
                // Fill beyond max
                for (let i = 0; i < 30; i++) {
                    window.recordRoll((i % 6) + 1);
                }
                assert(
                    window.rollHistory.rolls.length
                        <= window.rollHistory.maxHistory,
                    'rolls should not exceed maxHistory'
                );
            });

            // Test 93: getRollPercentages function exists
            test('History: getRollPercentages exists', () => {
                assert(typeof window.getRollPercentages === 'function',
                    'getRollPercentages should be a function');
            });

            // Test 94: getRollPercentages returns valid percentages
            test('History: percentages are valid', () => {
                const pcts = window.getRollPercentages();
                for (let face = 1; face <= 6; face++) {
                    assert(
                        typeof pcts[face] === 'number',
                        `face ${face} should have percentage`
                    );
                    assert(pcts[face] >= 0 && pcts[face] <= 100,
                        `face ${face} percentage should be 0-100`);
                }
            });

            // Test 95: percentages sum to ~100 (with rounding)
            test('History: percentages sum correctly', () => {
                // Only test if there are rolls
                if (window.rollHistory.totalRolls > 0) {
                    const pcts = window.getRollPercentages();
                    let sum = 0;
                    for (let face = 1; face <= 6; face++) {
                        sum += pcts[face];
                    }
                    // Allow for rounding errors (95-105%)
                    assert(sum >= 95 && sum <= 105,
                        `percentages should sum to ~100, got ${sum}`);
                } else {
                    assert(true, 'no rolls yet');
                }
            });

            // Test 96: recordRoll ignores invalid values
            test('History: rejects invalid roll values', () => {
                const before = window.rollHistory.totalRolls;
                window.recordRoll(0);   // Invalid
                window.recordRoll(7);   // Invalid
                window.recordRoll(-1);  // Invalid
                eq(window.rollHistory.totalRolls, before);
            });

            // Test 97: History UI elements exist
            test('History: UI elements exist', () => {
                assert(
                    document.getElementById('historyRolls') !== null,
                    'rolls container should exist'
                );
                assert(
                    document.getElementById('historyTotalRolls') !== null,
                    'total display should exist'
                );
                assert(
                    document.getElementById('historyDistribution') !== null,
                    'distribution should exist'
                );
            });

            // Test 98: History tab expands on click
            test('History: tab expands on header click', () => {
                const tab = document.getElementById('historyTab');
                const header = document.getElementById('historyHeader');
                
                // Start collapsed
                tab.classList.remove('expanded');
                assert(
                    !tab.classList.contains('expanded'),
                    'should start collapsed'
                );
                
                // Click header
                header.click();
                assert(
                    tab.classList.contains('expanded'),
                    'should expand on click'
                );
                
                // Collapse again
                header.click();
                assert(
                    !tab.classList.contains('expanded'),
                    'should collapse on second click'
                );
            });

            // Test 99: Distribution bars update
            test('History: distribution bars update', () => {
                const distContainer =
                    document.getElementById('historyDistribution');
                assert(
                    distContainer.innerHTML.length > 0,
                    'distribution should have content'
                );
                assert(
                    distContainer.querySelectorAll(
                        '.history-bar-container'
                    ).length === 6,
                    'should have 6 distribution bars'
                );
            });

            // ------------------------------------------------------------
            // Sound Tests
            // Verify rolling sound toggle and roll lifecycle behavior
            // ------------------------------------------------------------

            test('Sound: checkbox exists and default off', () => {
                const cb = document.getElementById('historySoundEnabled');
                assert(cb !== null, 'sound checkbox should exist');
                eq(Boolean(cb.checked), false);
                eq(Boolean(soundEnabled), false);
            });

            test('Sound: disabled does not create AudioContext', () => {
                withMockAudioContext((state) => {
                    soundEnabled = false;
                    soundCtx = null;
                    stopRollingForTests();

                    withRafQueue(() => {
                        rollDice(1);
                        eq(state.constructed, 0);
                        stopRollingForTests();
                    });
                });
            });

            test('Sound: enabling starts sound on roll', () => {
                withMockAudioContext((state) => {
                    const cb = document.getElementById('historySoundEnabled');
                    assert(cb !== null, 'sound checkbox should exist');

                    soundCtx = null;
                    cb.checked = true;
                    cb.dispatchEvent(new Event('change'));
                    eq(Boolean(soundEnabled), true);

                    withRafQueue(() => {
                        rollDice(2);
                        eq(state.constructed, 1);
                        assert(state.starts >= 1, 'should start sound nodes');
                        stopRollingForTests();
                    });

                    cb.checked = false;
                    cb.dispatchEvent(new Event('change'));
                });
            });

            test('Sound: disabling during roll stops sound', () => {
                withMockAudioContext((state) => {
                    const cb = document.getElementById('historySoundEnabled');
                    assert(cb !== null, 'sound checkbox should exist');

                    soundCtx = null;
                    cb.checked = true;
                    cb.dispatchEvent(new Event('change'));

                    withRafQueue(() => {
                        rollDice(3);
                        assert(state.starts >= 1, 'should start sound nodes');
                        cb.checked = false;
                        cb.dispatchEvent(new Event('change'));
                        assert(state.stops >= 1, 'should stop sound nodes');
                        stopRollingForTests();
                    });
                });
            });

            test('Sound: enabling during roll starts sound', () => {
                withMockAudioContext((state) => {
                    const cb = document.getElementById('historySoundEnabled');
                    assert(cb !== null, 'sound checkbox should exist');

                    soundEnabled = false;
                    soundCtx = null;

                    withRafQueue(() => {
                        rollDice(4);
                        eq(state.starts, 0);
                        const startsBefore = state.starts;
                        cb.checked = true;
                        cb.dispatchEvent(new Event('change'));
                        assert(state.starts >= 1, 'should start sound nodes');
                        assert(
                            state.starts > startsBefore,
                            'should start during roll'
                        );
                        stopRollingForTests();
                    });

                    cb.checked = false;
                    cb.dispatchEvent(new Event('change'));
                });
            });

            test('Sound: roll completion stops sound', () => {
                withMockAudioContext((state) => {
                    const cb = document.getElementById('historySoundEnabled');
                    assert(cb !== null, 'sound checkbox should exist');

                    soundCtx = null;
                    cb.checked = true;
                    cb.dispatchEvent(new Event('change'));

                    withRafQueue(({ flushNamed }) => {
                        rollDice(5);
                        assert(state.starts >= 1, 'should start sound nodes');
                        const stopsBefore = state.stops;
                        const dur = window.lastRollDuration;
                        const base = performance.now();
                        const t1 = base + dur * 1.01;
                        assert(flushNamed('animate', t1), 'animate should run');
                        assert(state.stops > stopsBefore, 'should stop sound');
                        stopRollingForTests();
                    });

                    cb.checked = false;
                    cb.dispatchEvent(new Event('change'));
                });
            });

            test('Sound: restarting roll restarts sound', () => {
                withMockAudioContext((state) => {
                    const cb = document.getElementById('historySoundEnabled');
                    assert(cb !== null, 'sound checkbox should exist');

                    soundCtx = null;
                    cb.checked = true;
                    cb.dispatchEvent(new Event('change'));

                    withRafQueue(({ flushNamed }) => {
                        rollDice(1);
                        assert(state.starts >= 1, 'should start sound nodes');
                        const startsBefore = state.starts;
                        const stopsBefore = state.stops;
                        rollDice(2);
                        assert(state.stops > stopsBefore, 'should stop sound');
                        assert(
                            state.starts > startsBefore,
                            'should restart sound'
                        );

                        const dur = window.lastRollDuration;
                        const base = performance.now();
                        const t1 = base + dur * 1.01;
                        assert(flushNamed('animate', t1), 'animate should run');
                        assert(state.stops >= 2, 'should stop sound again');
                        stopRollingForTests();
                    });

                    cb.checked = false;
                    cb.dispatchEvent(new Event('change'));
                });
            });

            test('Confetti: max roll shows burst', () => {
                const layer = document.getElementById('confettiLayer');
                assert(layer !== null, 'confetti layer should exist');
                layer.innerHTML = '';

                withRafQueue(({ flushNamed }) => {
                    rollDice(6);
                    const dur = window.lastRollDuration;
                    const base = performance.now();
                    const t1 = base + dur * 1.01;
                    assert(flushNamed('animate', t1), 'animate should run');
                    assert(layer.children.length > 0, 'burst should spawn');
                    stopRollingForTests();
                    layer.innerHTML = '';
                });
            });

            test('Confetti: non-max roll shows no burst', () => {
                const layer = document.getElementById('confettiLayer');
                assert(layer !== null, 'confetti layer should exist');
                layer.innerHTML = '';

                withRafQueue(({ flushNamed }) => {
                    rollDice(5);
                    const dur = window.lastRollDuration;
                    const base = performance.now();
                    const t1 = base + dur * 1.01;
                    assert(flushNamed('animate', t1), 'animate should run');
                    eq(layer.children.length, 0);
                    stopRollingForTests();
                    layer.innerHTML = '';
                });
            });

            test('Celebration: does not play when disabled', () => {
                window.celebrationPlayCount = 0;
                soundEnabled = false;
                soundCtx = null;

                withRafQueue(({ flushNamed }) => {
                    rollDice(6);
                    const dur = window.lastRollDuration;
                    const base = performance.now();
                    const t1 = base + dur * 1.01;
                    assert(flushNamed('animate', t1), 'animate should run');
                    eq(window.celebrationPlayCount, 0);
                    stopRollingForTests();
                });
            });

            test('Celebration: plays on max when enabled', () => {
                withMockAudioContext(() => {
                    const cb = document.getElementById('historySoundEnabled');
                    assert(cb !== null, 'sound checkbox should exist');

                    window.celebrationPlayCount = 0;
                    celebrationLastPlayTime = -Infinity;
                    soundCtx = null;
                    cb.checked = true;
                    cb.dispatchEvent(new Event('change'));

                    withRafQueue(({ flushNamed }) => {
                        rollDice(6);
                        const dur = window.lastRollDuration;
                        const base = performance.now();
                        const t1 = base + dur * 1.01;
                        assert(flushNamed('animate', t1), 'animate should run');
                        eq(window.celebrationPlayCount, 1);
                        stopRollingForTests();
                    });

                    cb.checked = false;
                    cb.dispatchEvent(new Event('change'));
                });
            });

            test('Config: face count input exists', () => {
                const input = document.getElementById('faceCount');
                assert(input !== null, 'face count input should exist');
                eq(input.getAttribute('min'), '2');
                eq(input.getAttribute('max'), '20');
                eq(String(input.value), '6');
            });

            test('Config: d20 max triggers confetti', () => {
                const layer = document.getElementById('confettiLayer');
                assert(layer !== null, 'confetti layer should exist');
                layer.innerHTML = '';

                const prev = diceFaceCount;
                setDiceFaceCount(20);
                eq(window.diceFaceCount, 20);

                const dist = document.getElementById('historyDistribution');
                assert(dist !== null, 'distribution should exist');
                assert(
                    dist.querySelectorAll('.history-bar-container').length
                        === 20,
                    'should show 20 distribution bars'
                );

                withRafQueue(({ flushNamed }) => {
                    rollDice(20);
                    const dur = window.lastRollDuration;
                    const base = performance.now();
                    const t1 = base + dur * 1.01;
                    assert(flushNamed('animateFlat', t1), 'animate should run');
                    assert(layer.children.length > 0, 'burst should spawn');
                    stopRollingForTests();
                });

                setDiceFaceCount(prev);
                layer.innerHTML = '';
            });

            test('Details: face count control mounted in Details', () => {
                const control = document.getElementById('faceCountControl');
                const mount = document.getElementById('detailsDieControls');
                assert(control !== null, 'face count control should exist');
                assert(mount !== null, 'details mount should exist');
                assert(
                    mount.contains(control),
                    'control should be inside Details mount'
                );
            });

            test('Details: expanded content is scrollable', () => {
                const tab = document.getElementById('historyTab');
                const header = document.getElementById('historyHeader');
                const content = document.getElementById('historyContent');
                assert(tab !== null, 'details tab should exist');
                assert(header !== null, 'details header should exist');
                assert(content !== null, 'details content should exist');

                tab.classList.remove('expanded');
                header.click();
                assert(
                    tab.classList.contains('expanded'),
                    'details should be expanded'
                );

                const cs = getComputedStyle(content);
                eq(cs.overflowY, 'auto');
                assert(
                    cs.paddingRight !== '0px',
                    'padding-right should reserve scrollbar space'
                );

                tab.classList.remove('expanded');
            });

            test('Mode: d2 shows coin and hint', () => {
                const prev = diceFaceCount;
                setDiceFaceCount(2);

                const cube = document.getElementById('dice');
                const dieFlat = document.getElementById('die2d');
                const coinEl = document.getElementById('coin');
                const hint = document.getElementById('faceCountHint');

                assert(cube !== null, 'cube should exist');
                assert(dieFlat !== null, 'die2d should exist');
                assert(coinEl !== null, 'coin should exist');
                assert(hint !== null, 'hint should exist');

                eq(coinEl.style.display, 'flex');
                eq(coinEl.getAttribute('aria-hidden'), 'false');
                eq(dieFlat.style.display, 'none');
                eq(dieFlat.getAttribute('aria-hidden'), 'true');
                eq(cube.style.display, 'none');
                assert(
                    hint.textContent.includes('H'),
                    'hint should indicate Heads/Tails'
                );

                setDiceFaceCount(prev);
            });

            test('Mode: d7 sets polygon clip-path', () => {
                const prev = diceFaceCount;
                setDiceFaceCount(7);

                const dieFlat = document.getElementById('die2d');
                assert(dieFlat !== null, 'die2d should exist');
                eq(dieFlat.style.display, 'flex');

                const clip = dieFlat.style.getPropertyValue('--die2d-clip');
                assert(clip.includes('polygon('), 'clip-path should be polygon');

                const inner = clip
                    .replace('polygon(', '')
                    .replace(')', '')
                    .trim();
                const points = inner.length ? inner.split(',') : [];
                eq(points.length, 7);

                setDiceFaceCount(prev);
            });

            test('Roll: d2 shows Heads/Tails and records H/T', () => {
                const prev = diceFaceCount;
                setDiceFaceCount(2);
                resetRollHistory();

                const rolls = document.getElementById('historyRolls');
                const dist = document.getElementById('historyDistribution');
                assert(rolls !== null, 'rolls should exist');
                assert(dist !== null, 'distribution should exist');

                withRafQueue(({ flushNamed }) => {
                    rollDice(1);
                    const dur = window.lastRollDuration;
                    const base = performance.now();
                    const tReveal = base + dur * 0.71;
                    assert(flushNamed('animateCoin', tReveal), 'coin should run');

                    assert(result !== null, 'result should exist');
                    eq(result.textContent, 'Heads');
                    assert(result.classList.contains('show'), 'result should show');

                    assert(
                        rolls.textContent.includes('H'),
                        'last rolls should contain H'
                    );
                    assert(
                        dist.textContent.includes('H'),
                        'distribution should contain H'
                    );
                    assert(
                        dist.textContent.includes('T'),
                        'distribution should contain T'
                    );

                    stopRollingForTests();
                });

                setDiceFaceCount(prev);
            });

            test('Roll: d2 toss arc lifts and lands', () => {
                const prev = diceFaceCount;
                setDiceFaceCount(2);

                const coinEl = document.getElementById('coin');
                assert(coinEl !== null, 'coin should exist');

                withRafQueue(({ flushNamed }) => {
                    rollDice(2);
                    const dur = window.lastRollDuration;
                    const base = performance.now();

                    const tMid = base + dur * 0.50;
                    assert(flushNamed('animateCoin', tMid), 'coin should run');
                    const yMid = parseFloat(
                        coinEl.style.getPropertyValue('--coin-y')
                    );
                    assert(yMid < 0, 'coin should lift upward (negative y)');

                    const tEnd = base + dur * 1.01;
                    assert(flushNamed('animateCoin', tEnd), 'coin should finish');
                    const yEnd = parseFloat(
                        coinEl.style.getPropertyValue('--coin-y')
                    );
                    assert(Math.abs(yEnd) < 0.1, 'coin should land near y=0');

                    stopRollingForTests();
                });

                setDiceFaceCount(prev);
            });

            test('Roll: d2 end rotation aligns to face', () => {
                const prev = diceFaceCount;
                setDiceFaceCount(2);

                rollDice(1);
                assert(
                    window.lastRollRotationPlan,
                    'rotation plan should exist'
                );
                eq(window.lastRollRotationPlan.mode, 'coin');
                const end1 = mod360(window.lastRollRotationPlan.endZ);
                assert(end1 < 0.2 || Math.abs(end1 - 360) < 0.2, 'ends at 0');
                stopRollingForTests();

                rollDice(2);
                assert(
                    window.lastRollRotationPlan,
                    'rotation plan should exist'
                );
                eq(window.lastRollRotationPlan.mode, 'coin');
                const end2 = mod360(window.lastRollRotationPlan.endZ);
                assert(Math.abs(end2 - 180) < 0.2, 'ends at 180');
                stopRollingForTests();

                setDiceFaceCount(prev);
            });

            test('Sound: d2 coin sound starts/stops when enabled', () => {
                withMockAudioContext((state) => {
                    const cb = document.getElementById('historySoundEnabled');
                    assert(cb !== null, 'sound checkbox should exist');

                    const prev = diceFaceCount;
                    soundEnabled = false;
                    soundCtx = null;
                    stopRollingForTests();
                    setDiceFaceCount(2);

                    cb.checked = true;
                    cb.dispatchEvent(new Event('change'));

                    withRafQueue(({ flushNamed }) => {
                        rollDice(1);
                        const dur = window.lastRollDuration;
                        const base = performance.now();
                        const tEnd = base + dur * 1.01;
                        assert(
                            flushNamed('animateCoin', tEnd),
                            'coin should finish'
                        );
                        eq(state.constructed, 1);
                        assert(state.starts >= 1, 'should start sound nodes');
                        assert(state.stops >= 1, 'should stop sound nodes');
                        assert(
                            state.oscillators >= 1,
                            'coin sound should create oscillators'
                        );
                        stopRollingForTests();
                    });

                    cb.checked = false;
                    cb.dispatchEvent(new Event('change'));
                    setDiceFaceCount(prev);
                });
            });

            test('Sound: d2 coin sound silent when disabled', () => {
                withMockAudioContext((state) => {
                    const cb = document.getElementById('historySoundEnabled');
                    assert(cb !== null, 'sound checkbox should exist');

                    soundEnabled = false;
                    soundCtx = null;
                    stopRollingForTests();

                    cb.checked = false;
                    cb.dispatchEvent(new Event('change'));

                    const prev = diceFaceCount;
                    setDiceFaceCount(2);

                    withRafQueue(({ flushNamed }) => {
                        rollDice(2);
                        const dur = window.lastRollDuration;
                        const base = performance.now();
                        const tMid = base + dur * 0.20;
                        assert(
                            flushNamed('animateCoin', tMid),
                            'coin should run'
                        );
                        eq(state.constructed, 0);
                        eq(state.starts, 0);
                        eq(state.stops, 0);
                        eq(state.oscillators, 0);
                        stopRollingForTests();
                    });

                    setDiceFaceCount(prev);
                });
            });

            test('Config: face count out of range is invalid', () => {
                const input = document.getElementById('faceCount');
                assert(input !== null, 'face count input should exist');

                input.value = '1';
                input.dispatchEvent(new Event('input'));
                eq(input.getAttribute('aria-invalid'), 'true');

                input.value = '21';
                input.dispatchEvent(new Event('input'));
                eq(input.getAttribute('aria-invalid'), 'true');

                input.value = '2';
                input.dispatchEvent(new Event('input'));
                eq(input.getAttribute('aria-invalid'), 'false');

                input.value = '20';
                input.dispatchEvent(new Event('input'));
                eq(input.getAttribute('aria-invalid'), 'false');
            });

            test('History: distribution deviation colors', () => {
                const prev = diceFaceCount;
                setDiceFaceCount(6);

                rollHistory.counts = makeCounts(6);
                rollHistory.totalRolls = 60;
                rollHistory.counts[1] = 10;
                rollHistory.counts[2] = 15;
                rollHistory.counts[3] = 11;
                rollHistory.counts[4] = 12;
                rollHistory.counts[5] = 12;
                rollHistory.counts[6] = 0;
                updateHistoryUI();

                const dist = document.getElementById('historyDistribution');
                assert(dist !== null, 'distribution should exist');
                const rows = Array.from(
                    dist.querySelectorAll('.history-bar-container')
                );

                function fillFor(labelText) {
                    for (const row of rows) {
                        const lab = row.querySelector('.history-bar-label');
                        if (!lab) {
                            continue;
                        }
                        if (String(lab.textContent).trim() === labelText) {
                            return row.querySelector('.history-bar-fill');
                        }
                    }
                    return null;
                }

                const f1 = fillFor('1');
                const f2 = fillFor('2');
                const f6 = fillFor('6');
                assert(f1 !== null, 'face 1 fill should exist');
                assert(f2 !== null, 'face 2 fill should exist');
                assert(f6 !== null, 'face 6 fill should exist');
                assert(f1.classList.contains('dist-good'), '1 should be good');
                assert(f2.classList.contains('dist-ok'), '2 should be ok');
                assert(f6.classList.contains('dist-bad'), '6 should be bad');

                setDiceFaceCount(prev);
            });

            test('URL: faces query param sets face count', () => {
                const prev = diceFaceCount;
                setDiceFaceCount(6);

                const applied = applyFacesParamFromSearch('?faces=20');
                eq(applied, true);
                eq(diceFaceCount, 20);

                const label = document.getElementById('die2dLabel');
                assert(label !== null, 'die2dLabel should exist');
                eq(label.textContent, 'D20');

                setDiceFaceCount(prev);
            });

            test('URL: invalid faces param is ignored', () => {
                const prev = diceFaceCount;
                setDiceFaceCount(6);

                const applied = applyFacesParamFromSearch('?faces=not-a-number');
                eq(applied, false);
                eq(diceFaceCount, 6);

                setDiceFaceCount(prev);
            });
        }
    </script>
</body>
</html>
